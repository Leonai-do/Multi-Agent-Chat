Directory structure:
└── groq-groq-typescript/
    ├── README.md
    ├── api.md
    ├── Brewfile
    ├── CHANGELOG.md
    ├── CODEOWNERS
    ├── CONTRIBUTING.md
    ├── jest.config.ts
    ├── LICENSE
    ├── package.json
    ├── release-please-config.json
    ├── SECURITY.md
    ├── tsc-multi.json
    ├── tsconfig.build.json
    ├── tsconfig.deno.json
    ├── tsconfig.dist-src.json
    ├── tsconfig.json
    ├── .eslintrc.js
    ├── .prettierignore
    ├── .prettierrc.json
    ├── .release-please-manifest.json
    ├── .stats.yml
    ├── examples/
    │   ├── chat_completion.js
    │   ├── chat_completion_stop.js
    │   ├── chat_completion_streaming.js
    │   └── .keep
    ├── scripts/
    │   ├── bootstrap
    │   ├── format
    │   ├── lint
    │   ├── mock
    │   ├── test
    │   └── utils/
    │       ├── check-is-in-git-install.sh
    │       ├── check-version.cjs
    │       ├── fix-index-exports.cjs
    │       ├── git-swap.sh
    │       ├── make-dist-package-json.cjs
    │       ├── postprocess-files.cjs
    │       └── upload-artifact.sh
    ├── src/
    │   ├── core.ts
    │   ├── error.ts
    │   ├── index.ts
    │   ├── resource.ts
    │   ├── resources.ts
    │   ├── uploads.ts
    │   ├── version.ts
    │   ├── _shims/
    │   │   ├── README.md
    │   │   ├── bun-runtime.ts
    │   │   ├── index-deno.ts
    │   │   ├── index.d.ts
    │   │   ├── index.js
    │   │   ├── index.mjs
    │   │   ├── manual-types.d.ts
    │   │   ├── manual-types.js
    │   │   ├── manual-types.mjs
    │   │   ├── MultipartBody.ts
    │   │   ├── node-runtime.ts
    │   │   ├── node-types.d.ts
    │   │   ├── node-types.js
    │   │   ├── node-types.mjs
    │   │   ├── registry.ts
    │   │   ├── web-runtime.ts
    │   │   ├── web-types.d.ts
    │   │   ├── web-types.js
    │   │   ├── web-types.mjs
    │   │   └── auto/
    │   │       ├── runtime-bun.ts
    │   │       ├── runtime-deno.ts
    │   │       ├── runtime-node.ts
    │   │       ├── runtime.ts
    │   │       ├── types-deno.ts
    │   │       ├── types-node.ts
    │   │       ├── types.d.ts
    │   │       ├── types.js
    │   │       └── types.mjs
    │   ├── lib/
    │   │   ├── streaming.ts
    │   │   └── .keep
    │   ├── resources/
    │   │   ├── audio.ts
    │   │   ├── batches.ts
    │   │   ├── chat.ts
    │   │   ├── completions.ts
    │   │   ├── embeddings.ts
    │   │   ├── files.ts
    │   │   ├── index.ts
    │   │   ├── models.ts
    │   │   ├── shared.ts
    │   │   ├── audio/
    │   │   │   ├── audio.ts
    │   │   │   ├── index.ts
    │   │   │   ├── speech.ts
    │   │   │   ├── transcriptions.ts
    │   │   │   └── translations.ts
    │   │   └── chat/
    │   │       ├── chat.ts
    │   │       └── index.ts
    │   └── shims/
    │       ├── node.ts
    │       └── web.ts
    ├── tests/
    │   ├── form.test.ts
    │   ├── index.test.ts
    │   ├── responses.test.ts
    │   ├── stringifyQuery.test.ts
    │   ├── uploads.test.ts
    │   └── api-resources/
    │       ├── batches.test.ts
    │       ├── embeddings.test.ts
    │       ├── files.test.ts
    │       ├── models.test.ts
    │       ├── audio/
    │       │   ├── speech.test.ts
    │       │   ├── transcriptions.test.ts
    │       │   └── translations.test.ts
    │       └── chat/
    │           └── completions.test.ts
    ├── .devcontainer/
    │   └── devcontainer.json
    └── .github/
        └── workflows/
            ├── ci.yml
            ├── publish-npm.yml
            ├── release-doctor.yml
            └── stale.yaml

================================================
FILE: README.md
================================================
# Groq Node API Library

[![NPM version](https://img.shields.io/npm/v/groq-sdk.svg)](https://npmjs.org/package/groq-sdk) ![npm bundle size](https://img.shields.io/bundlephobia/minzip/groq-sdk)

This library provides convenient access to the Groq REST API from server-side TypeScript or JavaScript.

The REST API documentation can be found on [console.groq.com](https://console.groq.com/docs). The full API of this library can be found in [api.md](api.md).

It is generated with [Stainless](https://www.stainless.com/).

## Installation

```sh
npm install groq-sdk
```

## Usage

The full API of this library can be found in [api.md](api.md).

<!-- prettier-ignore -->
```js
import Groq from 'groq-sdk';

const client = new Groq({
  apiKey: process.env['GROQ_API_KEY'], // This is the default and can be omitted
});

const chatCompletion = await client.chat.completions.create({
  messages: [{ role: 'user', content: 'Explain the importance of low latency LLMs' }],
  model: 'openai/gpt-oss-20b',
});

console.log(chatCompletion.choices[0].message.content);
```

### Request & Response types

This library includes TypeScript definitions for all request params and response fields. You may import and use them like so:

<!-- prettier-ignore -->
```ts
import Groq from 'groq-sdk';

const client = new Groq({
  apiKey: process.env['GROQ_API_KEY'], // This is the default and can be omitted
});

const params: Groq.Chat.CompletionCreateParams = {
  messages: [
    { role: 'system', content: 'You are a helpful assistant.' },
    { role: 'user', content: 'Explain the importance of low latency LLMs' },
  ],
  model: 'openai/gpt-oss-20b',
};
const chatCompletion: Groq.Chat.ChatCompletion = await client.chat.completions.create(params);
```

Documentation for each method, request param, and response field are available in docstrings and will appear on hover in most modern editors.

## File uploads

Request parameters that correspond to file uploads can be passed in many different forms:

- `File` (or an object with the same structure)
- a `fetch` `Response` (or an object with the same structure)
- an `fs.ReadStream`
- the return value of our `toFile` helper

```ts
import fs from 'fs';
import fetch from 'node-fetch';
import Groq, { toFile } from 'groq-sdk';

const client = new Groq();

// If you have access to Node `fs` we recommend using `fs.createReadStream()`:
await client.audio.transcriptions.create({
  model: 'whisper-large-v3-turbo',
  file: fs.createReadStream('/path/to/file'),
});

// Or if you have the web `File` API you can pass a `File` instance:
await client.audio.transcriptions.create({
  model: 'whisper-large-v3-turbo',
  file: new File(['my bytes'], 'file'),
});

// You can also pass a `fetch` `Response`:
await client.audio.transcriptions.create({
  model: 'whisper-large-v3-turbo',
  file: await fetch('https://somesite/file'),
});

// Finally, if none of the above are convenient, you can use our `toFile` helper:
await client.audio.transcriptions.create({
  model: 'whisper-large-v3-turbo',
  file: await toFile(Buffer.from('my bytes'), 'file'),
});
await client.audio.transcriptions.create({
  model: 'whisper-large-v3-turbo',
  file: await toFile(new Uint8Array([0, 1, 2]), 'file'),
});
```

## Handling errors

When the library is unable to connect to the API,
or if the API returns a non-success status code (i.e., 4xx or 5xx response),
a subclass of `APIError` will be thrown:

<!-- prettier-ignore -->
```ts
const chatCompletion = await client.chat.completions
  .create({
    messages: [
      { role: 'system', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Explain the importance of low latency LLMs' },
    ],
    model: 'openai/gpt-oss-20b',
  })
  .catch(async (err) => {
    if (err instanceof Groq.APIError) {
      console.log(err.status); // 400
      console.log(err.name); // BadRequestError
      console.log(err.headers); // {server: 'nginx', ...}
    } else {
      throw err;
    }
  });
```

Error codes are as follows:

| Status Code | Error Type                 |
| ----------- | -------------------------- |
| 400         | `BadRequestError`          |
| 401         | `AuthenticationError`      |
| 403         | `PermissionDeniedError`    |
| 404         | `NotFoundError`            |
| 422         | `UnprocessableEntityError` |
| 429         | `RateLimitError`           |
| >=500       | `InternalServerError`      |
| N/A         | `APIConnectionError`       |

### Retries

Certain errors will be automatically retried 2 times by default, with a short exponential backoff.
Connection errors (for example, due to a network connectivity problem), 408 Request Timeout, 409 Conflict,
429 Rate Limit, and >=500 Internal errors will all be retried by default.

You can use the `maxRetries` option to configure or disable this:

<!-- prettier-ignore -->
```js
// Configure the default for all requests:
const client = new Groq({
  maxRetries: 0, // default is 2
});

// Or, configure per-request:
await client.chat.completions.create({ messages: [{ role: 'system', content: 'You are a helpful assistant.' }, { role: 'user', content: 'Explain the importance of low latency LLMs' }], model: 'openai/gpt-oss-20b' }, {
  maxRetries: 5,
});
```

### Timeouts

Requests time out after 1 minute by default. You can configure this with a `timeout` option:

<!-- prettier-ignore -->
```ts
// Configure the default for all requests:
const client = new Groq({
  timeout: 20 * 1000, // 20 seconds (default is 1 minute)
});

// Override per-request:
await client.chat.completions.create({ messages: [{ role: 'system', content: 'You are a helpful assistant.' }, { role: 'user', content: 'Explain the importance of low latency LLMs' }], model: 'openai/gpt-oss-20b' }, {
  timeout: 5 * 1000,
});
```

On timeout, an `APIConnectionTimeoutError` is thrown.

Note that requests which time out will be [retried twice by default](#retries).

## Advanced Usage

### Accessing raw Response data (e.g., headers)

The "raw" `Response` returned by `fetch()` can be accessed through the `.asResponse()` method on the `APIPromise` type that all methods return.

You can also use the `.withResponse()` method to get the raw `Response` along with the parsed data.

<!-- prettier-ignore -->
```ts
const client = new Groq();

const response = await client.chat.completions
  .create({
    messages: [
      { role: 'system', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Explain the importance of low latency LLMs' },
    ],
    model: 'openai/gpt-oss-20b',
  })
  .asResponse();
console.log(response.headers.get('X-My-Header'));
console.log(response.statusText); // access the underlying Response object

const { data: chatCompletion, response: raw } = await client.chat.completions
  .create({
    messages: [
      { role: 'system', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Explain the importance of low latency LLMs' },
    ],
    model: 'openai/gpt-oss-20b',
  })
  .withResponse();
console.log(raw.headers.get('X-My-Header'));
console.log(chatCompletion.id);
```

### Making custom/undocumented requests

This library is typed for convenient access to the documented API. If you need to access undocumented
endpoints, params, or response properties, the library can still be used.

#### Undocumented endpoints

To make requests to undocumented endpoints, you can use `client.get`, `client.post`, and other HTTP verbs.
Options on the client, such as retries, will be respected when making these requests.

```ts
await client.post('/some/path', {
  body: { some_prop: 'foo' },
  query: { some_query_arg: 'bar' },
});
```

#### Undocumented request params

To make requests using undocumented parameters, you may use `// @ts-expect-error` on the undocumented
parameter. This library doesn't validate at runtime that the request matches the type, so any extra values you
send will be sent as-is.

```ts
client.foo.create({
  foo: 'my_param',
  bar: 12,
  // @ts-expect-error baz is not yet public
  baz: 'undocumented option',
});
```

For requests with the `GET` verb, any extra params will be in the query, all other requests will send the
extra param in the body.

If you want to explicitly send an extra argument, you can do so with the `query`, `body`, and `headers` request
options.

#### Undocumented response properties

To access undocumented response properties, you may access the response object with `// @ts-expect-error` on
the response object, or cast the response object to the requisite type. Like the request params, we do not
validate or strip extra properties from the response from the API.

### Customizing the fetch client

By default, this library uses `node-fetch` in Node, and expects a global `fetch` function in other environments.

If you would prefer to use a global, web-standards-compliant `fetch` function even in a Node environment,
(for example, if you are running Node with `--experimental-fetch` or using NextJS which polyfills with `undici`),
add the following import before your first import `from "Groq"`:

```ts
// Tell TypeScript and the package to use the global web fetch instead of node-fetch.
// Note, despite the name, this does not add any polyfills, but expects them to be provided if needed.
import 'groq-sdk/shims/web';
import Groq from 'groq-sdk';
```

To do the inverse, add `import "groq-sdk/shims/node"` (which does import polyfills).
This can also be useful if you are getting the wrong TypeScript types for `Response` ([more details](https://github.com/groq/groq-typescript/tree/main/src/_shims#readme)).

### Logging and middleware

You may also provide a custom `fetch` function when instantiating the client,
which can be used to inspect or alter the `Request` or `Response` before/after each request:

```ts
import { fetch } from 'undici'; // as one example
import Groq from 'groq-sdk';

const client = new Groq({
  fetch: async (url: RequestInfo, init?: RequestInit): Promise<Response> => {
    console.log('About to make a request', url, init);
    const response = await fetch(url, init);
    console.log('Got response', response);
    return response;
  },
});
```

Note that if given a `DEBUG=true` environment variable, this library will log all requests and responses automatically.
This is intended for debugging purposes only and may change in the future without notice.

### Configuring an HTTP(S) Agent (e.g., for proxies)

By default, this library uses a stable agent for all http/https requests to reuse TCP connections, eliminating many TCP & TLS handshakes and shaving around 100ms off most requests.

If you would like to disable or customize this behavior, for example to use the API behind a proxy, you can pass an `httpAgent` which is used for all requests (be they http or https), for example:

<!-- prettier-ignore -->
```ts
import http from 'http';
import { HttpsProxyAgent } from 'https-proxy-agent';

// Configure the default for all requests:
const client = new Groq({
  httpAgent: new HttpsProxyAgent(process.env.PROXY_URL),
});

// Override per-request:
await client.chat.completions.create(
  {
    messages: [
      { role: 'system', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Explain the importance of low latency LLMs' },
    ],
    model: 'openai/gpt-oss-20b',
  },
  {
    httpAgent: new http.Agent({ keepAlive: false }),
  },
);
```

## Semantic versioning

This package generally follows [SemVer](https://semver.org/spec/v2.0.0.html) conventions, though certain backwards-incompatible changes may be released as minor versions:

1. Changes that only affect static types, without breaking runtime behavior.
2. Changes to library internals which are technically public but not intended or documented for external use. _(Please open a GitHub issue to let us know if you are relying on such internals.)_
3. Changes that we do not expect to impact the vast majority of users in practice.

We take backwards-compatibility seriously and work hard to ensure you can rely on a smooth upgrade experience.

We are keen for your feedback; please open an [issue](https://www.github.com/groq/groq-typescript/issues) with questions, bugs, or suggestions.

## Requirements

TypeScript >= 4.5 is supported.

The following runtimes are supported:

- Node.js 18 LTS or later ([non-EOL](https://endoflife.date/nodejs)) versions.
- Deno v1.28.0 or higher.
- Bun 1.0 or later.
- Cloudflare Workers.
- Vercel Edge Runtime.
- Jest 28 or greater with the `"node"` environment (`"jsdom"` is not supported at this time).
- Nitro v2.6 or greater.
- Web browsers: disabled by default to avoid exposing your secret API credentials. Enable browser support by explicitly setting `dangerouslyAllowBrowser` to true'.
  <details>
    <summary>More explanation</summary>

  ### Why is this dangerous?

  Enabling the `dangerouslyAllowBrowser` option can be dangerous because it exposes your secret API credentials in the client-side code. Web browsers are inherently less secure than server environments,
  any user with access to the browser can potentially inspect, extract, and misuse these credentials. This could lead to unauthorized access using your credentials and potentially compromise sensitive data or functionality.

  ### When might this not be dangerous?

  In certain scenarios where enabling browser support might not pose significant risks:

  - Internal Tools: If the application is used solely within a controlled internal environment where the users are trusted, the risk of credential exposure can be mitigated.
  - Public APIs with Limited Scope: If your API has very limited scope and the exposed credentials do not grant access to sensitive data or critical operations, the potential impact of exposure is reduced.
  - Development or debugging purpose: Enabling this feature temporarily might be acceptable, provided the credentials are short-lived, aren't also used in production environments, or are frequently rotated.

</details>

Note that React Native is not supported at this time.

If you are interested in other runtime environments, please open or upvote an issue on GitHub.

## Contributing

See [the contributing documentation](./CONTRIBUTING.md).



================================================
FILE: api.md
================================================
# Shared

Types:

- <code><a href="./src/resources/shared.ts">ErrorObject</a></code>
- <code><a href="./src/resources/shared.ts">FunctionDefinition</a></code>
- <code><a href="./src/resources/shared.ts">FunctionParameters</a></code>

# Completions

Types:

- <code><a href="./src/resources/completions.ts">CompletionUsage</a></code>

# Chat

## Completions

Types:

- <code><a href="./src/resources/chat/completions.ts">ChatCompletion</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionAssistantMessageParam</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionChunk</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionContentPart</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionContentPartImage</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionContentPartText</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionFunctionCallOption</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionFunctionMessageParam</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionMessage</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionMessageParam</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionMessageToolCall</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionNamedToolChoice</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionRole</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionSystemMessageParam</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionTokenLogprob</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionTool</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionToolChoiceOption</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionToolMessageParam</a></code>
- <code><a href="./src/resources/chat/completions.ts">ChatCompletionUserMessageParam</a></code>

Methods:

- <code title="post /openai/v1/chat/completions">client.chat.completions.<a href="./src/resources/chat/completions.ts">create</a>({ ...params }) -> ChatCompletion</code>

# Embeddings

Types:

- <code><a href="./src/resources/embeddings.ts">CreateEmbeddingResponse</a></code>
- <code><a href="./src/resources/embeddings.ts">Embedding</a></code>

Methods:

- <code title="post /openai/v1/embeddings">client.embeddings.<a href="./src/resources/embeddings.ts">create</a>({ ...params }) -> CreateEmbeddingResponse</code>

# Audio

## Speech

Methods:

- <code title="post /openai/v1/audio/speech">client.audio.speech.<a href="./src/resources/audio/speech.ts">create</a>({ ...params }) -> Response</code>

## Transcriptions

Types:

- <code><a href="./src/resources/audio/transcriptions.ts">Transcription</a></code>

Methods:

- <code title="post /openai/v1/audio/transcriptions">client.audio.transcriptions.<a href="./src/resources/audio/transcriptions.ts">create</a>({ ...params }) -> Transcription</code>

## Translations

Types:

- <code><a href="./src/resources/audio/translations.ts">Translation</a></code>

Methods:

- <code title="post /openai/v1/audio/translations">client.audio.translations.<a href="./src/resources/audio/translations.ts">create</a>({ ...params }) -> Translation</code>

# Models

Types:

- <code><a href="./src/resources/models.ts">Model</a></code>
- <code><a href="./src/resources/models.ts">ModelDeleted</a></code>
- <code><a href="./src/resources/models.ts">ModelListResponse</a></code>

Methods:

- <code title="get /openai/v1/models/{model}">client.models.<a href="./src/resources/models.ts">retrieve</a>(model) -> Model</code>
- <code title="get /openai/v1/models">client.models.<a href="./src/resources/models.ts">list</a>() -> ModelListResponse</code>
- <code title="delete /openai/v1/models/{model}">client.models.<a href="./src/resources/models.ts">delete</a>(model) -> ModelDeleted</code>

# Batches

Types:

- <code><a href="./src/resources/batches.ts">BatchCreateResponse</a></code>
- <code><a href="./src/resources/batches.ts">BatchRetrieveResponse</a></code>
- <code><a href="./src/resources/batches.ts">BatchListResponse</a></code>
- <code><a href="./src/resources/batches.ts">BatchCancelResponse</a></code>

Methods:

- <code title="post /openai/v1/batches">client.batches.<a href="./src/resources/batches.ts">create</a>({ ...params }) -> BatchCreateResponse</code>
- <code title="get /openai/v1/batches/{batch_id}">client.batches.<a href="./src/resources/batches.ts">retrieve</a>(batchId) -> BatchRetrieveResponse</code>
- <code title="get /openai/v1/batches">client.batches.<a href="./src/resources/batches.ts">list</a>() -> BatchListResponse</code>
- <code title="post /openai/v1/batches/{batch_id}/cancel">client.batches.<a href="./src/resources/batches.ts">cancel</a>(batchId) -> BatchCancelResponse</code>

# Files

Types:

- <code><a href="./src/resources/files.ts">FileCreateResponse</a></code>
- <code><a href="./src/resources/files.ts">FileListResponse</a></code>
- <code><a href="./src/resources/files.ts">FileDeleteResponse</a></code>
- <code><a href="./src/resources/files.ts">FileInfoResponse</a></code>

Methods:

- <code title="post /openai/v1/files">client.files.<a href="./src/resources/files.ts">create</a>({ ...params }) -> FileCreateResponse</code>
- <code title="get /openai/v1/files">client.files.<a href="./src/resources/files.ts">list</a>() -> FileListResponse</code>
- <code title="delete /openai/v1/files/{file_id}">client.files.<a href="./src/resources/files.ts">delete</a>(fileId) -> FileDeleteResponse</code>
- <code title="get /openai/v1/files/{file_id}/content">client.files.<a href="./src/resources/files.ts">content</a>(fileId) -> Response</code>
- <code title="get /openai/v1/files/{file_id}">client.files.<a href="./src/resources/files.ts">info</a>(fileId) -> FileInfoResponse</code>



================================================
FILE: Brewfile
================================================
brew "node"



================================================
FILE: CHANGELOG.md
================================================
# Changelog

## 0.31.0 (2025-09-02)

Full Changelog: [v0.30.0...v0.31.0](https://github.com/groq/groq-typescript/compare/v0.30.0...v0.31.0)

### Features

* **api:** api update ([be48d38](https://github.com/groq/groq-typescript/commit/be48d38f749dc4599ab71633ff226583f6e74b02))
* **api:** api update ([44424c2](https://github.com/groq/groq-typescript/commit/44424c26018f43b69682bebca7e9c734b5d0f1e0))
* **api:** api update ([f772446](https://github.com/groq/groq-typescript/commit/f772446f655ff905c14f40f45cafc4109ef7f912))
* **api:** api update ([2e12bd1](https://github.com/groq/groq-typescript/commit/2e12bd1022f8cd168d41b62d753615b3900ee1f1))
* **api:** api update ([61a9e99](https://github.com/groq/groq-typescript/commit/61a9e99c984e43432d823388435893408d84ce0f))


### Bug Fixes

* update example model from decommissioned models to gpt-oss-20b ([1c69897](https://github.com/groq/groq-typescript/commit/1c69897c7fe09a0d0df5f041749a17a95ed878cd))


### Chores

* **deps:** update dependency node-fetch to v2.6.13 ([4938496](https://github.com/groq/groq-typescript/commit/49384963049a83b196e87595046e7686fcdfcca0))
* **internal:** formatting change ([a287d5e](https://github.com/groq/groq-typescript/commit/a287d5e41f1b6bba338b0cc3e1b9212a35b4e824))
* **internal:** move publish config ([5fe1890](https://github.com/groq/groq-typescript/commit/5fe1890402075a67d6ea4472b6196273cd0b0f9e))
* **internal:** update comment in script ([2a69a41](https://github.com/groq/groq-typescript/commit/2a69a4195d773bd0c6c1dcc0e49824ed6f50b24d))
* update @stainless-api/prism-cli to v5.15.0 ([35cd683](https://github.com/groq/groq-typescript/commit/35cd68309611e5e77f04974ce18b516116f3346d))
* update CI script ([e863bc0](https://github.com/groq/groq-typescript/commit/e863bc04c0324e2b5cdf2fab8abe36e2c4469907))

## 0.30.0 (2025-08-05)

Full Changelog: [v0.29.0...v0.30.0](https://github.com/groq/groq-typescript/compare/v0.29.0...v0.30.0)

### Features

* **api:** api update ([eeeabc3](https://github.com/groq/groq-typescript/commit/eeeabc31656b0a694d6dd792e1543da5b112e222))
* **api:** api update ([f4d1f1e](https://github.com/groq/groq-typescript/commit/f4d1f1e1ac0758af0241455a350e3006b43f9c92))
* **api:** api update ([fa21dc1](https://github.com/groq/groq-typescript/commit/fa21dc163c1de01e59e024e4bd6c6814c240b440))
* **api:** api update ([d7f2dd5](https://github.com/groq/groq-typescript/commit/d7f2dd57cd260f0549029dac955103dbe8ac649b))
* **api:** api update ([7f524c7](https://github.com/groq/groq-typescript/commit/7f524c70cdac5fcc301c3b87c2c90b2b49446395))
* **api:** api update ([60e7655](https://github.com/groq/groq-typescript/commit/60e76555b02e2b53a9893d2b72ae0ed95ece37b9))


### Bug Fixes

* correct syntax error on readme ([#236](https://github.com/groq/groq-typescript/issues/236)) ([1a7534b](https://github.com/groq/groq-typescript/commit/1a7534baaded306cb7c99f0fb5ddcbe915dae9b3))


### Chores

* **internal:** remove redundant imports config ([72ac77d](https://github.com/groq/groq-typescript/commit/72ac77d93649ab4753e5820385ae994b60d40c6f))

## 0.29.0 (2025-07-23)

Full Changelog: [v0.28.0...v0.29.0](https://github.com/groq/groq-typescript/compare/v0.28.0...v0.29.0)

### Features

* Add initial Stainless SDK ([a6c643b](https://github.com/groq/groq-typescript/commit/a6c643bfc3b59145b1441fe927798de63b935992))
* Add transcription and translation endpoints ([3ca9b9d](https://github.com/groq/groq-typescript/commit/3ca9b9dd211e04638875e509c3ea518f481568cd))
* **api:** Add embeddings endpoint ([3a02ebd](https://github.com/groq/groq-typescript/commit/3a02ebd94b01b2b2de2cf2fbf358241c0c2a7b3e))
* **api:** Add support for image_url in chat user messages ([144fe9d](https://github.com/groq/groq-typescript/commit/144fe9ded04ffcef052ccee9a0ea8c371c58980a))
* **api:** api update ([ed9852b](https://github.com/groq/groq-typescript/commit/ed9852bbdbc91edc31011ef51b955fec67579138))
* **api:** api update ([230fa27](https://github.com/groq/groq-typescript/commit/230fa272f60d2a5de08fbd3487d0ffdc152ea823))
* **api:** api update ([e07b23b](https://github.com/groq/groq-typescript/commit/e07b23b0cc79f3182b57be960e9cd34774bf2fd3))
* **api:** Define OpenAI-compatible models ([ebfa13b](https://github.com/groq/groq-typescript/commit/ebfa13b110638a778b17562255a10d8d447e64cc))
* **api:** Fix audio transcription response formats ([3a31a46](https://github.com/groq/groq-typescript/commit/3a31a46170a0e074a4f904b01c293718507c7fbb))
* **api:** Improve types ([07519e3](https://github.com/groq/groq-typescript/commit/07519e33ebb9cdb5e1b3aea8cc1b8045b7d872d2))
* **api:** OpenAPI spec update via Stainless API ([#101](https://github.com/groq/groq-typescript/issues/101)) ([956c815](https://github.com/groq/groq-typescript/commit/956c8158316e7c9db2b0138099b363d7056706f7))
* **api:** OpenAPI spec update via Stainless API ([#104](https://github.com/groq/groq-typescript/issues/104)) ([23dad7b](https://github.com/groq/groq-typescript/commit/23dad7b0f9b00faa3d1a4049eb627dc30f70e0aa))
* **api:** OpenAPI spec update via Stainless API ([#110](https://github.com/groq/groq-typescript/issues/110)) ([cf51b70](https://github.com/groq/groq-typescript/commit/cf51b70a72792f336dd753414249970e05f7519e))
* **api:** OpenAPI spec update via Stainless API ([#112](https://github.com/groq/groq-typescript/issues/112)) ([5cd4b79](https://github.com/groq/groq-typescript/commit/5cd4b79fe6ac94cc7abf8a25c20fb58ce1adff35))
* **api:** Tool calling features ([2f39a2b](https://github.com/groq/groq-typescript/commit/2f39a2bb447f8384d2b6cbcb984ff1882a711a6e))
* **api:** update via SDK Studio ([#99](https://github.com/groq/groq-typescript/issues/99)) ([8d22b7a](https://github.com/groq/groq-typescript/commit/8d22b7a8651acc08d8d09f4af073c214dbd74b0a))
* create default branch ([48105eb](https://github.com/groq/groq-typescript/commit/48105eb898d6cc13c9fdd7e96989d657d9d30f4e))
* **internal:** handle streaming error ([266b55f](https://github.com/groq/groq-typescript/commit/266b55fd22cf6aa1a12c35627cf2b663e49b0068))
* OpenAPI spec update via Stainless API ([#11](https://github.com/groq/groq-typescript/issues/11)) ([55daf5a](https://github.com/groq/groq-typescript/commit/55daf5a04341cd6a5186eac722c9028275e05758))
* update via SDK Studio ([#10](https://github.com/groq/groq-typescript/issues/10)) ([ea2f15c](https://github.com/groq/groq-typescript/commit/ea2f15c2f232d3cadd34433c60001be4c198df39))
* update via SDK Studio ([#3](https://github.com/groq/groq-typescript/issues/3)) ([4737f58](https://github.com/groq/groq-typescript/commit/4737f5895239e4609e7cec544138f15a7729ebbf))
* update via SDK Studio ([#5](https://github.com/groq/groq-typescript/issues/5)) ([9ce715d](https://github.com/groq/groq-typescript/commit/9ce715d62c0aed65c2bbadacd1ad248f9363febd))
* update via SDK Studio ([#8](https://github.com/groq/groq-typescript/issues/8)) ([ab12814](https://github.com/groq/groq-typescript/commit/ab12814321d7d6035828a4e2c4a13771ed1c9933))


### Bug Fixes

* **compat:** remove ReadableStream polyfill redundant since node v16 ([#109](https://github.com/groq/groq-typescript/issues/109)) ([5e51345](https://github.com/groq/groq-typescript/commit/5e513456778480f29021f2604dcf3d40f2b8cd28))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([9d0bb04](https://github.com/groq/groq-typescript/commit/9d0bb04c153ed9584ac936956fa88c94384f8b63))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([5fa6983](https://github.com/groq/groq-typescript/commit/5fa6983323ea6376dfa1eb0f39906b721ea757d6))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([ab82c0a](https://github.com/groq/groq-typescript/commit/ab82c0a3ba00e63a92a88e24d25e4e41ec090951))
* patch streaming ([259791c](https://github.com/groq/groq-typescript/commit/259791c0f1505d4717739a869f51255bae378c4b))
* update import in chat_completions_ext.ts to address TS compilation error ([77f840b](https://github.com/groq/groq-typescript/commit/77f840b36f6ff223e4ced238515b2f1fcd606b6b))
* use absolute paths in /src/lib ([1dad17c](https://github.com/groq/groq-typescript/commit/1dad17ca7ceffe30a51ee0a2eef60a2ab72828ed))


### Chores

* add bklieger-groq CODEOWNERS ([64cf3cc](https://github.com/groq/groq-typescript/commit/64cf3cc9cabd4388491cd6132e595e31dbb2e22e))
* Add CODEOWNERS ([0e43bb5](https://github.com/groq/groq-typescript/commit/0e43bb5bff96da72c3d140b483f4e42e04635748))
* **api:** add response objects for translations and transcriptions ([5b1b0dc](https://github.com/groq/groq-typescript/commit/5b1b0dce366722100d0e826d9030c3a786551fe2))
* **api:** Internal SDK changes ([e171084](https://github.com/groq/groq-typescript/commit/e1710849c317deb2c6dc7f6a56483a18c56b6e10))
* **ci:** check for build errors ([#118](https://github.com/groq/groq-typescript/issues/118)) ([ff7c446](https://github.com/groq/groq-typescript/commit/ff7c44650b38ff11e8a4bf8e1f593d32b2b10c39))
* **ci:** limit release doctor target branches ([#107](https://github.com/groq/groq-typescript/issues/107)) ([7fd2f89](https://github.com/groq/groq-typescript/commit/7fd2f891e6631f96bc7f1a992b8dfb9fe4e1cbe8))
* **deps:** bump braces from 3.0.2 to 3.0.3 ([1f51f4b](https://github.com/groq/groq-typescript/commit/1f51f4b2515851536736cb1247d26c8d23cd2e66))
* **deps:** bump cross-spawn from 7.0.3 to 7.0.6 ([#138](https://github.com/groq/groq-typescript/issues/138)) ([fe33cf4](https://github.com/groq/groq-typescript/commit/fe33cf41b160b6ce7ab932c4ed71902287766e03))
* **deps:** bump form-data from 3.0.1 to 3.0.4 ([#234](https://github.com/groq/groq-typescript/issues/234)) ([6b32830](https://github.com/groq/groq-typescript/commit/6b32830db2013d2d77a56a52f3be79cb441fa20c))
* **deps:** bump micromatch from 4.0.5 to 4.0.8 ([31935c9](https://github.com/groq/groq-typescript/commit/31935c9e52bb410d37eab35f5759af3f7e48c813))
* **docs:** use client instead of package name in Node examples ([#106](https://github.com/groq/groq-typescript/issues/106)) ([802ea6b](https://github.com/groq/groq-typescript/commit/802ea6ba4ee6f0fb8bc858d51ef9b6edd3491e14))
* fix code owners ([4297164](https://github.com/groq/groq-typescript/commit/42971644d5c8eebd50484eaadd978ae2e9f540e1))
* Fix streaming before release ([8706723](https://github.com/groq/groq-typescript/commit/870672382758da56fbf37d3707091ce9131d8897))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([6ec8975](https://github.com/groq/groq-typescript/commit/6ec8975f7f6c2e5337d08fc74631c0968f979213))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([1543aeb](https://github.com/groq/groq-typescript/commit/1543aeb885e0938b5289e477b34fb962754fffa0))
* go live ([#1](https://github.com/groq/groq-typescript/issues/1)) ([e00abda](https://github.com/groq/groq-typescript/commit/e00abdae68a21bd45c984afb099f157f4c5619e6))
* **internal:** codegen related update ([#105](https://github.com/groq/groq-typescript/issues/105)) ([9a00ec7](https://github.com/groq/groq-typescript/commit/9a00ec755f2ccca5a59b541b545bc92eeb8be73d))
* **internal:** codegen related update ([#111](https://github.com/groq/groq-typescript/issues/111)) ([32862a2](https://github.com/groq/groq-typescript/commit/32862a2e9ff49b85ce18e331474cf08f63c74613))
* **tests:** update prism version ([#108](https://github.com/groq/groq-typescript/issues/108)) ([e619600](https://github.com/groq/groq-typescript/commit/e61960001f46f1470f6411a8c3dfbada5f8ce52b))
* update branch ([#7](https://github.com/groq/groq-typescript/issues/7)) ([6c2aee1](https://github.com/groq/groq-typescript/commit/6c2aee192c19fd4bd90b73af479d6b7137728665))

## 0.28.0 (2025-07-23)

Full Changelog: [v0.27.0...v0.28.0](https://github.com/groq/groq-typescript/compare/v0.27.0...v0.28.0)

### Features

* **api:** api update ([ed9852b](https://github.com/groq/groq-typescript/commit/ed9852bbdbc91edc31011ef51b955fec67579138))
* **api:** api update ([230fa27](https://github.com/groq/groq-typescript/commit/230fa272f60d2a5de08fbd3487d0ffdc152ea823))
* **api:** api update ([e07b23b](https://github.com/groq/groq-typescript/commit/e07b23b0cc79f3182b57be960e9cd34774bf2fd3))

## 0.27.0 (2025-07-11)

Full Changelog: [v0.26.0...v0.27.0](https://github.com/groq/groq-typescript/compare/v0.26.0...v0.27.0)

### Features

* **api:** api update ([1b32d00](https://github.com/groq/groq-typescript/commit/1b32d0026809d6f8ceeb898a2aa28bb6f4eb5819))
* **api:** api update ([5b76c71](https://github.com/groq/groq-typescript/commit/5b76c71097834901d37968967c45ba9371481686))


### Bug Fixes

* **ci:** release-doctor — report correct token name ([71f8629](https://github.com/groq/groq-typescript/commit/71f8629117963e69a2281d9a88eb784f765f78a8))
* **client:** don't send `Content-Type` for bodyless methods ([1e47c02](https://github.com/groq/groq-typescript/commit/1e47c02aa11b71739940e1ae8e7de1bf7d45c635))


### Chores

* add bklieger-groq CODEOWNERS ([64cf3cc](https://github.com/groq/groq-typescript/commit/64cf3cc9cabd4388491cd6132e595e31dbb2e22e))
* **ci:** only run for pushes and fork pull requests ([d64811d](https://github.com/groq/groq-typescript/commit/d64811dba9a5c298e9b5f974faa71666775f32c5))
* fix code owners ([4297164](https://github.com/groq/groq-typescript/commit/42971644d5c8eebd50484eaadd978ae2e9f540e1))
* make some internal functions async ([3abac30](https://github.com/groq/groq-typescript/commit/3abac30531d2e53db673af4527cee02c708e35f9))
* mention unit type in timeout docs ([7442523](https://github.com/groq/groq-typescript/commit/7442523935028d10afa5795aa5d9347b37aaa2ec))

## 0.26.0 (2025-06-25)

Full Changelog: [v0.25.0...v0.26.0](https://github.com/groq/groq-typescript/compare/v0.25.0...v0.26.0)

### Features

* **api:** api update ([825d036](https://github.com/groq/groq-typescript/commit/825d0365b71ce990120f79dbfb41bfb8906ae096))
* **client:** add support for endpoint-specific base URLs ([5e0c9a2](https://github.com/groq/groq-typescript/commit/5e0c9a2a10baf759b7a80b0f6f8970a857606d45))


### Bug Fixes

* publish script — handle NPM errors correctly ([d21aca8](https://github.com/groq/groq-typescript/commit/d21aca8397f197388bd8db033a448d7b0d74068d))


### Chores

* **ci:** enable for pull requests ([0693513](https://github.com/groq/groq-typescript/commit/0693513d6a53a5202281c0f4c5f76f5d9f28fcd4))
* **internal:** make base APIResource abstract ([f575770](https://github.com/groq/groq-typescript/commit/f57577082abbe103a4cb5102bd7fa9f230193983))


### Refactors

* **types:** replace Record with mapped types ([f0a7028](https://github.com/groq/groq-typescript/commit/f0a7028be09a3f18dc8db11b661a27d64627375a))

## 0.25.0 (2025-06-12)

Full Changelog: [v0.24.0...v0.25.0](https://github.com/groq/groq-typescript/compare/v0.24.0...v0.25.0)

### Features

* **api:** api update ([c7a3183](https://github.com/groq/groq-typescript/commit/c7a31832b59799ce7fb087cb118fa1057ff742d9))
* **api:** api update ([458d3cf](https://github.com/groq/groq-typescript/commit/458d3cfd76c82360358669d70758a66eadee4e74))
* **api:** api update ([d620864](https://github.com/groq/groq-typescript/commit/d62086446bb0f587f3b975690fde35d0708b72c6))

## 0.24.0 (2025-06-11)

Full Changelog: [v0.23.0...v0.24.0](https://github.com/groq/groq-typescript/compare/v0.23.0...v0.24.0)

### Features

* **api:** api update ([79a02be](https://github.com/groq/groq-typescript/commit/79a02beec00f9daf920f8e9a4cf341904ac083c5))


### Chores

* **docs:** use top-level-await in example snippets ([9277f5d](https://github.com/groq/groq-typescript/commit/9277f5da347d88d7236c2a5b2e57fee95727d186))

## 0.23.0 (2025-05-29)

Full Changelog: [v0.22.0...v0.23.0](https://github.com/groq/groq-typescript/compare/v0.22.0...v0.23.0)

### Features

* **api:** api update ([527632f](https://github.com/groq/groq-typescript/commit/527632fca9ab7589cef1b1eb9e74da6645706433))
* **api:** api update ([478f2e8](https://github.com/groq/groq-typescript/commit/478f2e8ab8f0c07fe5ae192d00c843b47f78bd6c))
* **api:** api update ([f25c88a](https://github.com/groq/groq-typescript/commit/f25c88a35d599425abe1e8b53951b4be1066eab5))


### Chores

* **docs:** grammar improvements ([bd25707](https://github.com/groq/groq-typescript/commit/bd25707f2a699527fb7f8ea9f055e3ef040f29c6))
* improve publish-npm script --latest tag logic ([40719b5](https://github.com/groq/groq-typescript/commit/40719b543d3cde8a62fb6366ee4fc5f1a1ffa028))

## 0.22.0 (2025-05-16)

Full Changelog: [v0.21.0...v0.22.0](https://github.com/groq/groq-typescript/compare/v0.21.0...v0.22.0)

### Features

* **api:** api update ([5899599](https://github.com/groq/groq-typescript/commit/58995997a4cd86506f1fab48aa6436e3aa64a9de))
* **api:** api update ([b346b49](https://github.com/groq/groq-typescript/commit/b346b4955a9f26006b701366083207fce52a7892))
* **api:** api update ([8da1401](https://github.com/groq/groq-typescript/commit/8da1401f0bab59e5df69e862b690ce84c30a2bf8))
* **api:** api update ([c742ce8](https://github.com/groq/groq-typescript/commit/c742ce8c0523590be3a6d38645448caefcfba125))


### Chores

* **ci:** bump node version for release workflows ([b11d937](https://github.com/groq/groq-typescript/commit/b11d937f5ac50f5098d0cae44b2838196c4d5e18))
* fix README example ([13533da](https://github.com/groq/groq-typescript/commit/13533da65012800adf7fa1be76828574ff042ea5))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([6ec8975](https://github.com/groq/groq-typescript/commit/6ec8975f7f6c2e5337d08fc74631c0968f979213))


### Documentation

* add examples to tsdocs ([a79829e](https://github.com/groq/groq-typescript/commit/a79829e38f1b585afb1e2b6e3de314226afaffde))
* remove or fix invalid readme examples ([934e30e](https://github.com/groq/groq-typescript/commit/934e30e30879f947cac6245f711b01eb90f63432))

## 0.21.0 (2025-05-01)

Full Changelog: [v0.20.1...v0.21.0](https://github.com/groq/groq-typescript/compare/v0.20.1...v0.21.0)

### Features

* **api:** api update ([d6447d8](https://github.com/groq/groq-typescript/commit/d6447d84e2996341008bb77860aa2b1a1893654f))


### Chores

* **ci:** only use depot for staging repos ([65bbde4](https://github.com/groq/groq-typescript/commit/65bbde447ced600f07cffe4dfeafb975d0d90246))
* **docs:** add missing deprecation warnings ([4fda471](https://github.com/groq/groq-typescript/commit/4fda471aa895a74b17671fabe59566fd17a9a0a4))
* **internal:** codegen related update ([83848bd](https://github.com/groq/groq-typescript/commit/83848bdf4dcb8ce3c8c5bdee11d14d648b7172f4))


### Documentation

* **readme:** fix typo ([7e506b6](https://github.com/groq/groq-typescript/commit/7e506b675dc84636715ad8314118525667e90bb5))

## 0.20.1 (2025-04-23)

Full Changelog: [v0.20.0...v0.20.1](https://github.com/groq/groq-typescript/compare/v0.20.0...v0.20.1)

### Bug Fixes

* **docs:** correct chatCompletion response exmaple in README ([399ccf5](https://github.com/groq/groq-typescript/commit/399ccf55ec7c0847bee32c9e214eecea5b8151c6))


### Chores

* **ci:** add timeout thresholds for CI jobs ([fc2c33e](https://github.com/groq/groq-typescript/commit/fc2c33ef10bb3796501831a7e36c73befadc8306))

## 0.20.0 (2025-04-22)

Full Changelog: [v0.19.0...v0.20.0](https://github.com/groq/groq-typescript/compare/v0.19.0...v0.20.0)

### Features

* **api:** api update ([00b8a36](https://github.com/groq/groq-typescript/commit/00b8a36b9101235badc0a5cf3b19287aaa9e38e3))
* **api:** api update ([b728dc4](https://github.com/groq/groq-typescript/commit/b728dc48b6a7686982dab67238d746276f223602))
* **api:** api update ([055b41b](https://github.com/groq/groq-typescript/commit/055b41bb1ca5e9d64833a3bc54c3afa1f0f16faa))
* **api:** api update ([74fea29](https://github.com/groq/groq-typescript/commit/74fea29aca74cf761a20d0cb4c51b522624a491b))
* **api:** api update ([970e970](https://github.com/groq/groq-typescript/commit/970e970e959ce756dd5194b9f758c10bed4b0485))
* **api:** api update ([cc72162](https://github.com/groq/groq-typescript/commit/cc72162da8f83deb1b8f5d65743c91b5f2fbd7d7))
* **api:** api update ([a945491](https://github.com/groq/groq-typescript/commit/a945491da14e55416dee482f1aac26f1daecfb01))


### Bug Fixes

* **api:** improve type resolution when importing as a package ([#222](https://github.com/groq/groq-typescript/issues/222)) ([45bea8e](https://github.com/groq/groq-typescript/commit/45bea8e84f6dfe75e599aec2b4a5268497914923))
* **client:** send `X-Stainless-Timeout` in seconds ([#219](https://github.com/groq/groq-typescript/issues/219)) ([49bc9d2](https://github.com/groq/groq-typescript/commit/49bc9d2621ff8fe5261c7f22d2283c67ff2883be))
* **mcp:** remove unused tools.ts ([#223](https://github.com/groq/groq-typescript/issues/223)) ([ac43270](https://github.com/groq/groq-typescript/commit/ac43270a148a19cce434c3c3fe7602fbf1b4eccc))


### Chores

* **client:** minor internal fixes ([bfebc04](https://github.com/groq/groq-typescript/commit/bfebc041673e0d23d287601cd694b572aa662b64))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([1543aeb](https://github.com/groq/groq-typescript/commit/1543aeb885e0938b5289e477b34fb962754fffa0))
* **internal:** add aliases for Record and Array ([#221](https://github.com/groq/groq-typescript/issues/221)) ([b4d3b51](https://github.com/groq/groq-typescript/commit/b4d3b5143d4cfa6cffd6b2424797feacac3e9229))
* **internal:** reduce CI branch coverage ([48fbdca](https://github.com/groq/groq-typescript/commit/48fbdca40c7127697544df18d6e91bdd52d2ebc9))
* **internal:** upload builds and expand CI branch coverage ([4bbba67](https://github.com/groq/groq-typescript/commit/4bbba6700d7dc0bd03dfa67940e0cc4b293a0213))
* **tests:** improve enum examples ([#224](https://github.com/groq/groq-typescript/issues/224)) ([3639c3b](https://github.com/groq/groq-typescript/commit/3639c3b255fa6e7f97c7a8d747297bc06e58f3f6))

## 0.19.0 (2025-04-02)

Full Changelog: [v0.18.0...v0.19.0](https://github.com/groq/groq-typescript/compare/v0.18.0...v0.19.0)

### Features

* **api:** add batch cancel ([0b0681f](https://github.com/groq/groq-typescript/commit/0b0681ff484dadce7a3f9ab8b5205683e96297fa))


### Chores

* **internal:** skip broken binary tests ([#217](https://github.com/groq/groq-typescript/issues/217)) ([6ad103f](https://github.com/groq/groq-typescript/commit/6ad103f2207357f876734b423c8224d48162c1f6))

## 0.18.0 (2025-04-01)

Full Changelog: [v0.17.0...v0.18.0](https://github.com/groq/groq-typescript/compare/v0.17.0...v0.18.0)

### Features

* **api:** api update ([#208](https://github.com/groq/groq-typescript/issues/208)) ([13e4080](https://github.com/groq/groq-typescript/commit/13e4080afb4a376d9c877cff2b95d3a3d5778b2a))
* **api:** api update ([#209](https://github.com/groq/groq-typescript/issues/209)) ([3b7ed98](https://github.com/groq/groq-typescript/commit/3b7ed98ce896b292f714611424707cc433962ea5))
* **api:** manual updates ([#210](https://github.com/groq/groq-typescript/issues/210)) ([01313a7](https://github.com/groq/groq-typescript/commit/01313a7b71e3127fd1cc1956e9062e4a155c4785))


### Bug Fixes

* avoid type error in certain environments ([#206](https://github.com/groq/groq-typescript/issues/206)) ([e75e67f](https://github.com/groq/groq-typescript/commit/e75e67f4cb8e4d243f78c221fcc58fda3d31b2b3))
* **internal:** work around https://github.com/vercel/next.js/issues/76881 ([#207](https://github.com/groq/groq-typescript/issues/207)) ([4c88261](https://github.com/groq/groq-typescript/commit/4c88261d1a96f255bece611f02cbbc2aec188dc3))


### Chores

* **exports:** cleaner resource index imports ([#204](https://github.com/groq/groq-typescript/issues/204)) ([ddf6d7e](https://github.com/groq/groq-typescript/commit/ddf6d7e0cec0785b100545b9cce44a961b830823))
* **exports:** stop using path fallbacks ([#205](https://github.com/groq/groq-typescript/issues/205)) ([3cad69e](https://github.com/groq/groq-typescript/commit/3cad69e475fa04129276dc3eaea30523df287054))
* **internal:** codegen related update ([#202](https://github.com/groq/groq-typescript/issues/202)) ([870089b](https://github.com/groq/groq-typescript/commit/870089b59e37b6dd34d6a60e37d4da2c980b07cf))

## 0.17.0 (2025-03-19)

Full Changelog: [v0.16.0...v0.17.0](https://github.com/groq/groq-typescript/compare/v0.16.0...v0.17.0)

### Features

* **api:** Add speech endpoint ([#197](https://github.com/groq/groq-typescript/issues/197)) ([a6c574a](https://github.com/groq/groq-typescript/commit/a6c574ae6d36e0f3932c5fbd509dde1369c9d7e6))
* **api:** api update ([#196](https://github.com/groq/groq-typescript/issues/196)) ([555d10a](https://github.com/groq/groq-typescript/commit/555d10ae221de301e41c5634bc1459d411bd66b8))
* **api:** api update ([#198](https://github.com/groq/groq-typescript/issues/198)) ([1b7f534](https://github.com/groq/groq-typescript/commit/1b7f5347e8a8b6f77d11de452f7bf07e291918c8))
* **api:** manual updates ([#190](https://github.com/groq/groq-typescript/issues/190)) ([2afb5be](https://github.com/groq/groq-typescript/commit/2afb5becd0f489f51c51c0fdd58c09b696b3adab))


### Bug Fixes

* **exports:** ensure resource imports don't require /index ([#195](https://github.com/groq/groq-typescript/issues/195)) ([3a54464](https://github.com/groq/groq-typescript/commit/3a544640461fa7e4402ef74181871aa469fc3ad2))


### Chores

* **api:** remove chat_completion_chunk to force a rebuild of it ([#188](https://github.com/groq/groq-typescript/issues/188)) ([8d1e9bf](https://github.com/groq/groq-typescript/commit/8d1e9bf99cda884e6c3312c5d6e3491dd3d3fa53))
* **internal:** remove extra empty newlines ([#194](https://github.com/groq/groq-typescript/issues/194)) ([f054a17](https://github.com/groq/groq-typescript/commit/f054a17f7f8fbbadb8e04d558d71b8967f216156))

## 0.16.0 (2025-03-11)

Full Changelog: [v0.15.0...v0.16.0](https://github.com/groq/groq-typescript/compare/v0.15.0...v0.16.0)

### Features

* add SKIP_BREW env var to ./scripts/bootstrap ([#186](https://github.com/groq/groq-typescript/issues/186)) ([7188745](https://github.com/groq/groq-typescript/commit/71887452485edb042aa49a813ca7295903641c73))
* **client:** accept RFC6838 JSON content types ([#187](https://github.com/groq/groq-typescript/issues/187)) ([8cb3baa](https://github.com/groq/groq-typescript/commit/8cb3baa9f05b4013ffae5e4199ee65d68d7d9b8c))
* **client:** send `X-Stainless-Timeout` header ([#180](https://github.com/groq/groq-typescript/issues/180)) ([a3372bc](https://github.com/groq/groq-typescript/commit/a3372bcccd5b68b6f9610a9e2fc5cf1d30c296d7))


### Bug Fixes

* **client:** fix export map for index exports ([#182](https://github.com/groq/groq-typescript/issues/182)) ([9537350](https://github.com/groq/groq-typescript/commit/9537350b6e19af0c1213ab85f6f2b697863e163d))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([9d0bb04](https://github.com/groq/groq-typescript/commit/9d0bb04c153ed9584ac936956fa88c94384f8b63))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([5fa6983](https://github.com/groq/groq-typescript/commit/5fa6983323ea6376dfa1eb0f39906b721ea757d6))


### Chores

* **internal:** codegen related update ([#183](https://github.com/groq/groq-typescript/issues/183)) ([203e3b1](https://github.com/groq/groq-typescript/commit/203e3b1102db8515143cdf536f1c9d583b85b3e5))
* **internal:** fix devcontainers setup ([#184](https://github.com/groq/groq-typescript/issues/184)) ([f0df22c](https://github.com/groq/groq-typescript/commit/f0df22cb095ef79933661922c802376f65182fb6))


### Documentation

* update URLs from stainlessapi.com to stainless.com ([#185](https://github.com/groq/groq-typescript/issues/185)) ([1c481a6](https://github.com/groq/groq-typescript/commit/1c481a6fa9fbc3bbe8901470022c2789cbe366e1))

## 0.15.0 (2025-02-05)

Full Changelog: [v0.14.0...v0.15.0](https://github.com/groq/groq-typescript/compare/v0.14.0...v0.15.0)

### Features

* **api:** Add batch API ([#177](https://github.com/groq/groq-typescript/issues/177)) ([0b62a9f](https://github.com/groq/groq-typescript/commit/0b62a9f0e3b53285cf4ca3c8884091626821a406))

## 0.14.0 (2025-02-03)

Full Changelog: [v0.13.0...v0.14.0](https://github.com/groq/groq-typescript/compare/v0.13.0...v0.14.0)

### Features

* **api:** api update ([#174](https://github.com/groq/groq-typescript/issues/174)) ([a8bdb17](https://github.com/groq/groq-typescript/commit/a8bdb179cdefe4fa29a3bcea692c01f166b83b86))

## 0.13.0 (2025-01-29)

Full Changelog: [v0.12.0...v0.13.0](https://github.com/groq/groq-typescript/compare/v0.12.0...v0.13.0)

### Features

* **api:** api update ([#172](https://github.com/groq/groq-typescript/issues/172)) ([f48946a](https://github.com/groq/groq-typescript/commit/f48946a46fccd5313565db3cac6143f536a4c5db))


### Chores

* **internal:** codegen related update ([#168](https://github.com/groq/groq-typescript/issues/168)) ([4d7399b](https://github.com/groq/groq-typescript/commit/4d7399bf51707ebbcdf43897fdd0d3abdfb8db7c))
* **internal:** codegen related update ([#170](https://github.com/groq/groq-typescript/issues/170)) ([2f4ee26](https://github.com/groq/groq-typescript/commit/2f4ee26019b86c3769674d44d7cf3e43c250b6d3))
* **internal:** codegen related update ([#171](https://github.com/groq/groq-typescript/issues/171)) ([99cf580](https://github.com/groq/groq-typescript/commit/99cf580cfdc334df24442319d0e56a4a1e8c7ceb))

## 0.12.0 (2025-01-11)

Full Changelog: [v0.11.0...v0.12.0](https://github.com/groq/groq-typescript/compare/v0.11.0...v0.12.0)

### Features

* **api:** api update ([#166](https://github.com/groq/groq-typescript/issues/166)) ([003600d](https://github.com/groq/groq-typescript/commit/003600d69f9b7a0171d5bb7a09202800d70875a9))


### Chores

* **internal:** codegen related update ([#164](https://github.com/groq/groq-typescript/issues/164)) ([72dfc54](https://github.com/groq/groq-typescript/commit/72dfc54e941be0d385baecd988cc6b0cd2854c19))

## 0.11.0 (2025-01-09)

Full Changelog: [v0.10.0...v0.11.0](https://github.com/groq/groq-typescript/compare/v0.10.0...v0.11.0)

### Features

* **api:** api update ([#161](https://github.com/groq/groq-typescript/issues/161)) ([5628b90](https://github.com/groq/groq-typescript/commit/5628b90da7336889b2d54e2033c065bcd8146e8e))

## 0.10.0 (2025-01-07)

Full Changelog: [v0.9.1...v0.10.0](https://github.com/groq/groq-typescript/compare/v0.9.1...v0.10.0)

### Features

* **api:** api update ([#157](https://github.com/groq/groq-typescript/issues/157)) ([3551087](https://github.com/groq/groq-typescript/commit/35510876e2e5c5295502bec56d09cbf759955bd2))
* **api:** api update ([#159](https://github.com/groq/groq-typescript/issues/159)) ([e0cbb97](https://github.com/groq/groq-typescript/commit/e0cbb978af53e25ba48b768d465c61fd08085f92))


### Bug Fixes

* **client:** normalize method ([#155](https://github.com/groq/groq-typescript/issues/155)) ([c3ba88c](https://github.com/groq/groq-typescript/commit/c3ba88c2f457c057b64331f5153a64d7051a65cf))


### Chores

* **internal:** codegen related update ([#149](https://github.com/groq/groq-typescript/issues/149)) ([4b1115b](https://github.com/groq/groq-typescript/commit/4b1115bc7dad629e6cbfd305d1f02c5d83c08cb4))
* **internal:** codegen related update ([#150](https://github.com/groq/groq-typescript/issues/150)) ([d582c40](https://github.com/groq/groq-typescript/commit/d582c40dfe47d45549a6edd91890ed7822f7af95))
* **internal:** codegen related update ([#151](https://github.com/groq/groq-typescript/issues/151)) ([e153d84](https://github.com/groq/groq-typescript/commit/e153d84e5b9208acfc5b0a368f2e580900f0958d))
* **internal:** codegen related update ([#152](https://github.com/groq/groq-typescript/issues/152)) ([33a4d9c](https://github.com/groq/groq-typescript/commit/33a4d9ce6b56a194001da9d75663e8498083d223))
* **internal:** codegen related update ([#153](https://github.com/groq/groq-typescript/issues/153)) ([dbb9d7f](https://github.com/groq/groq-typescript/commit/dbb9d7fdf457755f2d8a223e667423634ed18cf5))
* **internal:** codegen related update ([#154](https://github.com/groq/groq-typescript/issues/154)) ([579e30e](https://github.com/groq/groq-typescript/commit/579e30e19daaa9b0aaae2f9d5f268c7983f74376))
* **internal:** codegen related update ([#156](https://github.com/groq/groq-typescript/issues/156)) ([05f714b](https://github.com/groq/groq-typescript/commit/05f714b65c1251938d4d75a25e319a75907cf9d0))
* **internal:** codegen related update ([#158](https://github.com/groq/groq-typescript/issues/158)) ([265305a](https://github.com/groq/groq-typescript/commit/265305a5b3746b357b0bd2fe45080b373f2d1d7a))
* **internal:** fix some typos ([#147](https://github.com/groq/groq-typescript/issues/147)) ([476a620](https://github.com/groq/groq-typescript/commit/476a62017698e9b766d1ac0657e1dbdfd7af0cea))

## 0.9.1 (2024-12-12)

Full Changelog: [v0.9.0...v0.9.1](https://github.com/groq/groq-typescript/compare/v0.9.0...v0.9.1)

### Chores

* **internal:** remove unnecessary getRequestClient function ([#141](https://github.com/groq/groq-typescript/issues/141)) ([05ccf25](https://github.com/groq/groq-typescript/commit/05ccf251bb1e1bf0afc3af5572f4faf20ebd1410))
* **internal:** update isAbsoluteURL ([#145](https://github.com/groq/groq-typescript/issues/145)) ([18e414e](https://github.com/groq/groq-typescript/commit/18e414ed562876eb1dadff97a79aa2bbe90ff0ab))
* **types:** nicer error class types + jsdocs ([#144](https://github.com/groq/groq-typescript/issues/144)) ([860655e](https://github.com/groq/groq-typescript/commit/860655eb638047c681ed602002e1de8dfacb7d3d))

## 0.9.0 (2024-12-03)

Full Changelog: [v0.8.0...v0.9.0](https://github.com/groq/groq-typescript/compare/v0.8.0...v0.9.0)

### Features

* **api:** api update ([#133](https://github.com/groq/groq-typescript/issues/133)) ([9a22d20](https://github.com/groq/groq-typescript/commit/9a22d20b157fa1670d24cc0efae40081e53bfbd0))
* chore(deps): bump cross-spawn from 7.0.3 to 7.0.6 ([#138](https://github.com/groq/groq-typescript/issues/138)) ([ba61485](https://github.com/groq/groq-typescript/commit/ba61485623efcb4413b6019c48dbfaf9eec053cf))
* **internal:** make git install file structure match npm ([#137](https://github.com/groq/groq-typescript/issues/137)) ([0ae2b87](https://github.com/groq/groq-typescript/commit/0ae2b87c484394211a8f1df81a0a86fdb2082521))


### Chores

* **internal:** version bump ([#131](https://github.com/groq/groq-typescript/issues/131)) ([7ba4fdf](https://github.com/groq/groq-typescript/commit/7ba4fdf0782fd0525e14c1a3ac9df3379579ca55))
* rebuild project due to codegen change ([#134](https://github.com/groq/groq-typescript/issues/134)) ([e2711d6](https://github.com/groq/groq-typescript/commit/e2711d609491d4ba1b72db5844449e8aec18f80c))
* remove redundant word in comment ([#136](https://github.com/groq/groq-typescript/issues/136)) ([0b0cd01](https://github.com/groq/groq-typescript/commit/0b0cd01015cd2516c5d1b72f4ad495babacdb794))


### Documentation

* remove suggestion to use `npm` call out ([#135](https://github.com/groq/groq-typescript/issues/135)) ([29cb7b1](https://github.com/groq/groq-typescript/commit/29cb7b1b26f02c5284873da6380bbfe3e4099d88))

## 0.8.0 (2024-11-09)

Full Changelog: [v0.7.0...v0.8.0](https://github.com/groq/groq-typescript/compare/v0.7.0...v0.8.0)

### Features

* **api:** api update ([#127](https://github.com/groq/groq-typescript/issues/127)) ([5d82d2d](https://github.com/groq/groq-typescript/commit/5d82d2dd7119c17fdae3618b06c607b17ee00d67))
* **api:** api update ([#128](https://github.com/groq/groq-typescript/issues/128)) ([ae555c1](https://github.com/groq/groq-typescript/commit/ae555c1c6934b589e862ebd6b684cede0f09fb18))


### Bug Fixes

* **client:** correct File construction from node-fetch Responses ([#125](https://github.com/groq/groq-typescript/issues/125)) ([42a63ac](https://github.com/groq/groq-typescript/commit/42a63ac2bbf51fde1f61d94a61011d9a49822552))
* GitHub Terraform: Create/Update .github/workflows/stale.yaml [skip ci] ([ab82c0a](https://github.com/groq/groq-typescript/commit/ab82c0a3ba00e63a92a88e24d25e4e41ec090951))


### Chores

* **ci:** install deps via ./script/bootstrap ([#124](https://github.com/groq/groq-typescript/issues/124)) ([edc34d0](https://github.com/groq/groq-typescript/commit/edc34d08c51c8cae2ebbc32296dc9069a6547384))
* rebuild project due to codegen change ([#130](https://github.com/groq/groq-typescript/issues/130)) ([58bc1e8](https://github.com/groq/groq-typescript/commit/58bc1e81f7e89108cada06cf762b8de923849078))
* run tsc as part of lint script ([#122](https://github.com/groq/groq-typescript/issues/122)) ([85a3a56](https://github.com/groq/groq-typescript/commit/85a3a5617b69f87c8dcb4641e39b7302b7b9cfae))

## 0.7.0 (2024-09-03)

Full Changelog: [v0.6.1...v0.7.0](https://github.com/groq/groq-typescript/compare/v0.6.1...v0.7.0)

### Features

* **internal:** handle streaming error ([8f8f4eb](https://github.com/groq/groq-typescript/commit/8f8f4eb29c73229d2ffaa388c5d608291331c731))


### Chores

* **ci:** check for build errors ([#118](https://github.com/groq/groq-typescript/issues/118)) ([a784f84](https://github.com/groq/groq-typescript/commit/a784f842dc9785a127925da48c85531832c5d19b))

## 0.6.1 (2024-08-28)

Full Changelog: [v0.6.0...v0.6.1](https://github.com/groq/groq-typescript/compare/v0.6.0...v0.6.1)

### Chores

* **deps:** bump micromatch from 4.0.5 to 4.0.8 ([8cddd91](https://github.com/groq/groq-typescript/commit/8cddd9177aae4ab6b55b6e6e35ebb31bb074ce1e))

## 0.6.0 (2024-08-27)

Full Changelog: [v0.5.0...v0.6.0](https://github.com/groq/groq-typescript/compare/v0.5.0...v0.6.0)

### Features

* **api:** OpenAPI spec update via Stainless API ([#101](https://github.com/groq/groq-typescript/issues/101)) ([e2db04a](https://github.com/groq/groq-typescript/commit/e2db04a02b60bdf26a9590916f446250742cef8c))
* **api:** OpenAPI spec update via Stainless API ([#104](https://github.com/groq/groq-typescript/issues/104)) ([c08717b](https://github.com/groq/groq-typescript/commit/c08717ba3bbae8ea713f70672da295261fc26a28))
* **api:** OpenAPI spec update via Stainless API ([#110](https://github.com/groq/groq-typescript/issues/110)) ([c194ccd](https://github.com/groq/groq-typescript/commit/c194ccd2b3f2a5814892046af653a428fb3b1cfb))
* **api:** OpenAPI spec update via Stainless API ([#112](https://github.com/groq/groq-typescript/issues/112)) ([0b0cb13](https://github.com/groq/groq-typescript/commit/0b0cb138107945607fc3abef23e1ef2e355d748a))
* **api:** update via SDK Studio ([#99](https://github.com/groq/groq-typescript/issues/99)) ([e96de18](https://github.com/groq/groq-typescript/commit/e96de183786c91172ad59225f32b23265c9a7fb6))


### Bug Fixes

* **compat:** remove ReadableStream polyfill redundant since node v16 ([#109](https://github.com/groq/groq-typescript/issues/109)) ([90c2d43](https://github.com/groq/groq-typescript/commit/90c2d4340def37b2ad379ea838e63305e9dd4405))


### Chores

* **ci:** limit release doctor target branches ([#107](https://github.com/groq/groq-typescript/issues/107)) ([1409094](https://github.com/groq/groq-typescript/commit/1409094d1e87412fff2615f17783457ef815d088))
* **deps:** bump braces from 3.0.2 to 3.0.3 ([fedebb4](https://github.com/groq/groq-typescript/commit/fedebb4f2dfa2538db9dfdee47ba0581434ffc84))
* **docs:** use client instead of package name in Node examples ([#106](https://github.com/groq/groq-typescript/issues/106)) ([7279938](https://github.com/groq/groq-typescript/commit/727993848991d1fde8412a57d7781bdf4bd71641))
* **internal:** codegen related update ([#105](https://github.com/groq/groq-typescript/issues/105)) ([7b53f7c](https://github.com/groq/groq-typescript/commit/7b53f7cfa86fc0f4fc779bbc3fd112252b9d5260))
* **internal:** codegen related update ([#111](https://github.com/groq/groq-typescript/issues/111)) ([d81d781](https://github.com/groq/groq-typescript/commit/d81d7817f4c6c69f2ea91ff62c25b9162b4267bd))
* **tests:** update prism version ([#108](https://github.com/groq/groq-typescript/issues/108)) ([a2528da](https://github.com/groq/groq-typescript/commit/a2528da81262dcba2bd577af3f63166a43092a86))

## 0.5.0 (2024-06-11)

Full Changelog: [v0.4.0...v0.5.0](https://github.com/groq/groq-typescript/compare/v0.4.0...v0.5.0)

### Features

* **api:** Fix audio transcription response formats ([7154e35](https://github.com/groq/groq-typescript/commit/7154e35221cb906b853c0271ec4badeeef7c825b))
* **api:** Tool calling features ([e257ab7](https://github.com/groq/groq-typescript/commit/e257ab70890b4c8be0879696edf7379f5225566b))

## 0.4.0 (2024-05-23)

Full Changelog: [v0.3.3...v0.4.0](https://github.com/groq/groq-typescript/compare/v0.3.3...v0.4.0)

### Features

* **api:** Add embeddings endpoint ([cf59ec3](https://github.com/groq/groq-typescript/commit/cf59ec37bff37cb923eb389126f17931fcf97e2e))
* **api:** Add support for image_url in chat user messages ([a8f7743](https://github.com/groq/groq-typescript/commit/a8f7743e3663de628247df3a655938b3ed53231a))
* **api:** Define OpenAI-compatible models ([29fe116](https://github.com/groq/groq-typescript/commit/29fe116c88ad0d3c28562581f0929090833861ad))
* **api:** Improve types ([c879cb2](https://github.com/groq/groq-typescript/commit/c879cb29871aa247a60b984874ffca40a9ae924c))


### Bug Fixes

* patch streaming ([80b1255](https://github.com/groq/groq-typescript/commit/80b12555fcffd58bfd760b993e8bc3dcebfdbe6b))


### Chores

* **api:** add response objects for translations and transcriptions ([ceba2a3](https://github.com/groq/groq-typescript/commit/ceba2a3c7a398c25cd47f6cc42f655822877c53a))
* **api:** Internal SDK changes ([e1a6688](https://github.com/groq/groq-typescript/commit/e1a66880ec8843f5b9e62526ed31fbe34345a293))

## 0.3.3 (2024-04-29)

Full Changelog: [v0.3.2...v0.3.3](https://github.com/groq/groq-typescript/compare/v0.3.2...v0.3.3)

### Bug Fixes

* update import in chat_completions_ext.ts to address TS compilation error ([b1de786](https://github.com/groq/groq-typescript/commit/b1de7862495bd76b50b9b596d94bd5d7f2143f57))

## 0.3.2 (2024-03-08)

Full Changelog: [v0.3.1...v0.3.2](https://github.com/groq/groq-typescript/compare/v0.3.1...v0.3.2)

### Features

* Add transcription and translation endpoints ([5a422c4](https://github.com/groq/groq-typescript/commit/5a422c4f2c4d92d5a525ee63d674c92aff4990bb))


### Bug Fixes

* use absolute paths in /src/lib ([5c961f7](https://github.com/groq/groq-typescript/commit/5c961f7233ce5e4cfd32d3edcb9a845df7014b89))


### Chores

* Add CODEOWNERS ([e995ed1](https://github.com/groq/groq-typescript/commit/e995ed1214237379a1e4819a61876113e81a456b))
* Fix streaming before release ([b7463c5](https://github.com/groq/groq-typescript/commit/b7463c5690613c2142e10f3eb549e87471aea367))

## 0.3.1 (2024-03-01)

Full Changelog: [v0.3.0...v0.3.1](https://github.com/groq/groq-typescript/compare/v0.3.0...v0.3.1)

### Features

* OpenAPI spec update via Stainless API ([#11](https://github.com/groq/groq-typescript/issues/11)) ([3b8d249](https://github.com/groq/groq-typescript/commit/3b8d249e4bb70d960447bb1667b59e30baec1853))

## 0.3.0 (2024-02-21)

Full Changelog: [v0.2.1...v0.3.0](https://github.com/groq/groq-typescript/compare/v0.2.1...v0.3.0)

### Features

* update via SDK Studio ([#10](https://github.com/groq/groq-typescript/issues/10)) ([b9b5d6a](https://github.com/groq/groq-typescript/commit/b9b5d6af6cc2a37f404ec6685a9b950d9703cec5))
* update via SDK Studio ([#5](https://github.com/groq/groq-typescript/issues/5)) ([d6202e9](https://github.com/groq/groq-typescript/commit/d6202e9b12fa79c69fbe65c58fc716cd464f52f0))
* update via SDK Studio ([#8](https://github.com/groq/groq-typescript/issues/8)) ([cbbbe5b](https://github.com/groq/groq-typescript/commit/cbbbe5b357ff8673b3d310010d4c66ff5389bfa2))


### Chores

* update branch ([#7](https://github.com/groq/groq-typescript/issues/7)) ([5bd9088](https://github.com/groq/groq-typescript/commit/5bd9088546ebcfc0f857a3630fecf35f714d53a9))

## 0.2.0 (2024-02-15)

Full Changelog: [v0.1.0...v0.2.0](https://github.com/groq/groq-node/compare/v0.1.0...v0.2.0)

### Features

* Add initial Stainless SDK ([a6c643b](https://github.com/groq/groq-node/commit/a6c643bfc3b59145b1441fe927798de63b935992))
* create default branch ([48105eb](https://github.com/groq/groq-node/commit/48105eb898d6cc13c9fdd7e96989d657d9d30f4e))
* update via SDK Studio ([#3](https://github.com/groq/groq-node/issues/3)) ([c99373c](https://github.com/groq/groq-node/commit/c99373cdfd6b94a9d9346cf717a5354b378dc2f1))


### Chores

* go live ([#1](https://github.com/groq/groq-node/issues/1)) ([08d2551](https://github.com/groq/groq-node/commit/08d2551190a07ff8619ddc85a083eb130a33ff0b))

## 0.1.0 (2024-02-12)

Full Changelog: [v0.0.1...v0.1.0](https://github.com/definitive-io/groqcloud-node/compare/v0.0.1...v0.1.0)

### Features

* Add initial Stainless SDK ([73f0686](https://github.com/definitive-io/groqcloud-node/commit/73f0686f4dc84d332cf0eb072cad15dbd8594dea))
* create default branch ([9a37669](https://github.com/definitive-io/groqcloud-node/commit/9a376697847c0e7d9463cf5ad55ff469f59577cb))
* OpenAPI spec update ([#1](https://github.com/definitive-io/groqcloud-node/issues/1)) ([9ab0d58](https://github.com/definitive-io/groqcloud-node/commit/9ab0d580b2c9fa77b8e60a61e7711c605cb24f48))
* OpenAPI spec update ([#10](https://github.com/definitive-io/groqcloud-node/issues/10)) ([66870af](https://github.com/definitive-io/groqcloud-node/commit/66870afc708e452df9d75487cfec39c73c883adf))
* OpenAPI spec update ([#11](https://github.com/definitive-io/groqcloud-node/issues/11)) ([af63094](https://github.com/definitive-io/groqcloud-node/commit/af630946df953c20cb6ddd9dbbcef70a016c4147))
* OpenAPI spec update ([#12](https://github.com/definitive-io/groqcloud-node/issues/12)) ([8f55f00](https://github.com/definitive-io/groqcloud-node/commit/8f55f00afa2efe4d41a969ac92cc7302686ea9fe))
* OpenAPI spec update ([#13](https://github.com/definitive-io/groqcloud-node/issues/13)) ([ec65a86](https://github.com/definitive-io/groqcloud-node/commit/ec65a86b21d632d8785ea86c83d9ea8fbd49997b))
* OpenAPI spec update ([#3](https://github.com/definitive-io/groqcloud-node/issues/3)) ([18ca5ad](https://github.com/definitive-io/groqcloud-node/commit/18ca5ad6efa200b8dc000603a3c1d2c4b64a1a7c))
* OpenAPI spec update ([#4](https://github.com/definitive-io/groqcloud-node/issues/4)) ([7d3354a](https://github.com/definitive-io/groqcloud-node/commit/7d3354ad7a086e6b935934d09052086e9ca5161b))
* OpenAPI spec update ([#5](https://github.com/definitive-io/groqcloud-node/issues/5)) ([8a029ec](https://github.com/definitive-io/groqcloud-node/commit/8a029ec0f29d7a544d4c6ad88ed2d5856df77ed8))
* OpenAPI spec update ([#6](https://github.com/definitive-io/groqcloud-node/issues/6)) ([d45a00d](https://github.com/definitive-io/groqcloud-node/commit/d45a00d6d2d7ec67302e5bce0eba89d85998dd75))
* OpenAPI spec update ([#7](https://github.com/definitive-io/groqcloud-node/issues/7)) ([9142dad](https://github.com/definitive-io/groqcloud-node/commit/9142dade7bb345f47e348f300be2fd7beaa7e7d7))
* OpenAPI spec update ([#8](https://github.com/definitive-io/groqcloud-node/issues/8)) ([d143ade](https://github.com/definitive-io/groqcloud-node/commit/d143ade1cec62b4261d1661f62cb7c88f2cd22fb))
* OpenAPI spec update ([#9](https://github.com/definitive-io/groqcloud-node/issues/9)) ([2849be2](https://github.com/definitive-io/groqcloud-node/commit/2849be292711a6f8bf597458aa80e37ecc8e9716))



================================================
FILE: CODEOWNERS
================================================
* @gradenr @bklieger-groq



================================================
FILE: CONTRIBUTING.md
================================================
## Setting up the environment

This repository uses [`yarn@v1`](https://classic.yarnpkg.com/lang/en/docs/install).
Other package managers may work but are not officially supported for development.

To set up the repository, run:

```sh
$ yarn
$ yarn build
```

This will install all the required dependencies and build output files to `dist/`.

## Modifying/Adding code

Most of the SDK is generated code. Modifications to code will be persisted between generations, but may
result in merge conflicts between manual patches and changes from the generator. The generator will never
modify the contents of the `src/lib/` and `examples/` directories.

## Adding and running examples

All files in the `examples/` directory are not modified by the generator and can be freely edited or added to.

```ts
// add an example to examples/<your-example>.ts

#!/usr/bin/env -S npm run tsn -T
…
```

```sh
$ chmod +x examples/<your-example>.ts
# run the example against your api
$ yarn tsn -T examples/<your-example>.ts
```

## Using the repository from source

If you’d like to use the repository from source, you can either install from git or link to a cloned repository:

To install via git:

```sh
$ npm install git+ssh://git@github.com:groq/groq-typescript.git
```

Alternatively, to link a local copy of the repo:

```sh
# Clone
$ git clone https://www.github.com/groq/groq-typescript
$ cd groq-typescript

# With yarn
$ yarn link
$ cd ../my-package
$ yarn link groq-sdk

# With pnpm
$ pnpm link --global
$ cd ../my-package
$ pnpm link -—global groq-sdk
```

## Running tests

Most tests require you to [set up a mock server](https://github.com/stoplightio/prism) against the OpenAPI spec to run the tests.

```sh
$ npx prism mock path/to/your/openapi.yml
```

```sh
$ yarn run test
```

## Linting and formatting

This repository uses [prettier](https://www.npmjs.com/package/prettier) and
[eslint](https://www.npmjs.com/package/eslint) to format the code in the repository.

To lint:

```sh
$ yarn lint
```

To format and fix all lint issues automatically:

```sh
$ yarn fix
```

## Publishing and releases

Changes made to this repository via the automated release PR pipeline should publish to npm automatically. If
the changes aren't made through the automated pipeline, you may want to make releases manually.

### Publish with a GitHub workflow

You can release to package managers by using [the `Publish NPM` GitHub action](https://www.github.com/groq/groq-typescript/actions/workflows/publish-npm.yml). This requires a setup organization or repository secret to be set up.

### Publish manually

If you need to manually release a package, you can run the `bin/publish-npm` script with an `NPM_TOKEN` set on
the environment.



================================================
FILE: jest.config.ts
================================================
import type { JestConfigWithTsJest } from 'ts-jest';

const config: JestConfigWithTsJest = {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',
  transform: {
    '^.+\\.(t|j)sx?$': ['@swc/jest', { sourceMaps: 'inline' }],
  },
  moduleNameMapper: {
    '^groq-sdk$': '<rootDir>/src/index.ts',
    '^groq-sdk/_shims/auto/(.*)$': '<rootDir>/src/_shims/auto/$1-node',
    '^groq-sdk/(.*)$': '<rootDir>/src/$1',
  },
  modulePathIgnorePatterns: [
    '<rootDir>/ecosystem-tests/',
    '<rootDir>/dist/',
    '<rootDir>/deno/',
    '<rootDir>/deno_tests/',
  ],
  testPathIgnorePatterns: ['scripts'],
};

export default config;



================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Groq

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: package.json
================================================
{
  "name": "groq-sdk",
  "version": "0.31.0",
  "description": "The official TypeScript library for the Groq API",
  "author": "Groq <support@groq.com>",
  "types": "dist/index.d.ts",
  "main": "dist/index.js",
  "type": "commonjs",
  "repository": "github:groq/groq-typescript",
  "license": "Apache-2.0",
  "packageManager": "yarn@1.22.22",
  "files": [
    "**/*"
  ],
  "private": false,
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "test": "./scripts/test",
    "build": "./scripts/build",
    "prepublishOnly": "echo 'to publish, run yarn build && (cd dist; yarn publish)' && exit 1",
    "format": "prettier --write --cache --cache-strategy metadata . !dist",
    "prepare": "if ./scripts/utils/check-is-in-git-install.sh; then ./scripts/build && ./scripts/utils/git-swap.sh; fi",
    "tsn": "ts-node -r tsconfig-paths/register",
    "lint": "./scripts/lint",
    "fix": "./scripts/format"
  },
  "dependencies": {
    "@types/node": "^18.11.18",
    "@types/node-fetch": "^2.6.4",
    "abort-controller": "^3.0.0",
    "agentkeepalive": "^4.2.1",
    "form-data-encoder": "1.7.2",
    "formdata-node": "^4.3.2",
    "node-fetch": "^2.6.7"
  },
  "devDependencies": {
    "@swc/core": "^1.3.102",
    "@swc/jest": "^0.2.29",
    "@types/jest": "^29.4.0",
    "@typescript-eslint/eslint-plugin": "^6.7.0",
    "@typescript-eslint/parser": "^6.7.0",
    "eslint": "^8.49.0",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-unused-imports": "^3.0.0",
    "iconv-lite": "^0.6.3",
    "jest": "^29.4.0",
    "prettier": "^3.0.0",
    "ts-jest": "^29.1.0",
    "ts-node": "^10.5.0",
    "tsc-multi": "^1.1.0",
    "tsconfig-paths": "^4.0.0",
    "typescript": "^4.8.2"
  },
  "sideEffects": [
    "./_shims/index.js",
    "./_shims/index.mjs",
    "./shims/node.js",
    "./shims/node.mjs",
    "./shims/web.js",
    "./shims/web.mjs"
  ],
  "exports": {
    "./_shims/auto/*": {
      "deno": {
        "types": "./dist/_shims/auto/*.d.ts",
        "require": "./dist/_shims/auto/*.js",
        "default": "./dist/_shims/auto/*.mjs"
      },
      "bun": {
        "types": "./dist/_shims/auto/*.d.ts",
        "require": "./dist/_shims/auto/*-bun.js",
        "default": "./dist/_shims/auto/*-bun.mjs"
      },
      "browser": {
        "types": "./dist/_shims/auto/*.d.ts",
        "require": "./dist/_shims/auto/*.js",
        "default": "./dist/_shims/auto/*.mjs"
      },
      "worker": {
        "types": "./dist/_shims/auto/*.d.ts",
        "require": "./dist/_shims/auto/*.js",
        "default": "./dist/_shims/auto/*.mjs"
      },
      "workerd": {
        "types": "./dist/_shims/auto/*.d.ts",
        "require": "./dist/_shims/auto/*.js",
        "default": "./dist/_shims/auto/*.mjs"
      },
      "node": {
        "types": "./dist/_shims/auto/*-node.d.ts",
        "require": "./dist/_shims/auto/*-node.js",
        "default": "./dist/_shims/auto/*-node.mjs"
      },
      "types": "./dist/_shims/auto/*.d.ts",
      "require": "./dist/_shims/auto/*.js",
      "default": "./dist/_shims/auto/*.mjs"
    },
    ".": {
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "types": "./dist/index.d.mts",
      "default": "./dist/index.mjs"
    },
    "./*.mjs": {
      "types": "./dist/*.d.ts",
      "default": "./dist/*.mjs"
    },
    "./*.js": {
      "types": "./dist/*.d.ts",
      "default": "./dist/*.js"
    },
    "./*": {
      "types": "./dist/*.d.ts",
      "require": "./dist/*.js",
      "default": "./dist/*.mjs"
    }
  }
}



================================================
FILE: release-please-config.json
================================================
{
  "packages": {
    ".": {}
  },
  "$schema": "https://raw.githubusercontent.com/stainless-api/release-please/main/schemas/config.json",
  "include-v-in-tag": true,
  "include-component-in-tag": false,
  "versioning": "prerelease",
  "prerelease": true,
  "bump-minor-pre-major": true,
  "bump-patch-for-minor-pre-major": false,
  "pull-request-header": "Automated Release PR",
  "pull-request-title-pattern": "release: ${version}",
  "changelog-sections": [
    {
      "type": "feat",
      "section": "Features"
    },
    {
      "type": "fix",
      "section": "Bug Fixes"
    },
    {
      "type": "perf",
      "section": "Performance Improvements"
    },
    {
      "type": "revert",
      "section": "Reverts"
    },
    {
      "type": "chore",
      "section": "Chores"
    },
    {
      "type": "docs",
      "section": "Documentation"
    },
    {
      "type": "style",
      "section": "Styles"
    },
    {
      "type": "refactor",
      "section": "Refactors"
    },
    {
      "type": "test",
      "section": "Tests",
      "hidden": true
    },
    {
      "type": "build",
      "section": "Build System"
    },
    {
      "type": "ci",
      "section": "Continuous Integration",
      "hidden": true
    }
  ],
  "reviewers": [
    "gradenr"
  ],
  "release-type": "node",
  "extra-files": [
    "src/version.ts",
    "README.md"
  ]
}



================================================
FILE: SECURITY.md
================================================
# Security Policy

## Reporting Security Issues

This SDK is generated by [Stainless Software Inc](http://stainless.com). Stainless takes security seriously, and encourages you to report any security vulnerability promptly so that appropriate action can be taken.

To report a security issue, please contact the Stainless team at security@stainless.com.

## Responsible Disclosure

We appreciate the efforts of security researchers and individuals who help us maintain the security of
SDKs we generate. If you believe you have found a security vulnerability, please adhere to responsible
disclosure practices by allowing us a reasonable amount of time to investigate and address the issue
before making any information public.

## Reporting Non-SDK Related Security Issues

If you encounter security issues that are not directly related to SDKs but pertain to the services
or products provided by Groq, please follow the respective company's security reporting guidelines.

### Groq Terms and Policies

Please contact support@groq.com for any questions or concerns regarding the security of our services.

---

Thank you for helping us keep the SDKs and systems they interact with secure.



================================================
FILE: tsc-multi.json
================================================
{
  "targets": [
    { "extname": ".js", "module": "commonjs" },
    { "extname": ".mjs", "module": "esnext" }
  ],
  "projects": ["tsconfig.build.json"]
}



================================================
FILE: tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "include": ["dist/src"],
  "exclude": ["dist/src/_shims/*-deno.ts"],
  "compilerOptions": {
    "rootDir": "./dist/src",
    "paths": {
      "groq-sdk/*": ["dist/src/*"],
      "groq-sdk": ["dist/src/index.ts"],
    },
    "noEmit": false,
    "declaration": true,
    "declarationMap": true,
    "outDir": "dist",
    "pretty": true,
    "sourceMap": true
  }
}



================================================
FILE: tsconfig.deno.json
================================================
{
  "extends": "./tsconfig.json",
  "include": ["dist-deno"],
  "exclude": [],
  "compilerOptions": {
    "rootDir": "./dist-deno",
    "lib": ["es2020", "DOM"],
    "noEmit": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "dist-deno",
    "pretty": true,
    "sourceMap": true
  }
}



================================================
FILE: tsconfig.dist-src.json
================================================
{
  // this config is included in the published src directory to prevent TS errors
  // from appearing when users go to source, and VSCode opens the source .ts file
  // via declaration maps
  "include": ["index.ts"],
  "compilerOptions": {
    "target": "es2015",
    "lib": ["DOM"],
    "moduleResolution": "node"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "include": ["src", "tests", "examples"],
  "exclude": ["src/_shims/**/*-deno.ts"],
  "compilerOptions": {
    "target": "es2020",
    "lib": ["es2020"],
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "baseUrl": "./",
    "paths": {
      "groq-sdk/_shims/auto/*": ["src/_shims/auto/*-node"],
      "groq-sdk/*": ["src/*"],
      "groq-sdk": ["src/index.ts"]
    },
    "noEmit": true,

    "resolveJsonModule": true,

    "forceConsistentCasingInFileNames": true,

    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "noImplicitReturns": true,
    "alwaysStrict": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
		"isolatedModules": false,

    "skipLibCheck": true
  }
}



================================================
FILE: .eslintrc.js
================================================
module.exports = {
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint', 'unused-imports', 'prettier'],
  rules: {
    'no-unused-vars': 'off',
    'prettier/prettier': 'error',
    'unused-imports/no-unused-imports': 'error',
  },
  root: true,
};



================================================
FILE: .prettierignore
================================================
CHANGELOG.md
/ecosystem-tests/*/**
/node_modules
/deno

# don't format tsc output, will break source maps
/dist



================================================
FILE: .prettierrc.json
================================================
{
  "arrowParens": "always",
  "experimentalTernaries": true,
  "printWidth": 110,
  "singleQuote": true,
  "trailingComma": "all"
}



================================================
FILE: .release-please-manifest.json
================================================
{
  ".": "0.31.0"
}



================================================
FILE: .stats.yml
================================================
configured_endpoints: 17
openapi_spec_url: https://storage.googleapis.com/stainless-sdk-openapi-specs/groqcloud%2Fgroqcloud-a95a90928412afdb9cf5101b7fbb67ef2abbc4ecaa51ff18fa04643f9e8d2c95.yml
openapi_spec_hash: d2e5cb1562a2b2beb8673256252b9bf5
config_hash: 961b4995e909aef11a454befa56ad3d2



================================================
FILE: examples/chat_completion.js
================================================
const Groq = require('groq-sdk');

const groq = new Groq();

async function main() {
  groq.chat.completions
    .create({
      //
      // Required parameters
      //
      messages: [
        // Set an optional system message. This sets the behavior of the
        // assistant and can be used to provide specific instructions for
        // how it should behave throughout the conversation.
        {
          role: 'system',
          content: 'you are a helpful assistant.',
        },
        // Set a user message for the assistant to respond to.
        {
          role: 'user',
          content: 'Explain the importance of low latency LLMs',
        },
      ],

      // The language model which will generate the completion.
      model: 'mixtral-8x7b-32768',

      //
      // Optional parameters
      //

      // Controls randomness: lowering results in less random completions.
      // As the temperature approaches zero, the model will become deterministic
      // and repetitive.
      temperature: 0.5,

      // The maximum number of tokens to generate. Requests can use up to
      // 2048 tokens shared between prompt and completion.
      max_tokens: 1024,

      // Controls diversity via nucleus sampling: 0.5 means half of all
      // likelihood-weighted options are considered.
      top_p: 1,

      // A stop sequence is a predefined or user-specified text string that
      // signals an AI to stop generating content, ensuring its responses
      // remain focused and concise. Examples include punctuation marks and
      // markers like "[end]".
      stop: null,

      // If set, partial message deltas will be sent.
      stream: false,
    })
    .then((chatCompletion) => {
      process.stdout.write(chatCompletion.choices[0]?.message?.content || '');
    });
}

main();



================================================
FILE: examples/chat_completion_stop.js
================================================
const Groq = require('groq-sdk');

const groq = new Groq();

async function main() {
  const stream = await groq.chat.completions.create({
    //
    // Required parameters
    //
    messages: [
      // Set an optional system message. This sets the behavior of the
      // assistant and can be used to provide specific instructions for
      // how it should behave throughout the conversation.
      {
        role: 'system',
        content: 'you are a helpful assistant.',
      },
      // Set a user message for the assistant to respond to.
      {
        role: 'user',
        content: 'Start at 1 and count to 10.  Separate each number with a comma and a space',
      },
    ],

    // The language model which will generate the completion.
    model: 'mixtral-8x7b-32768',

    //
    // Optional parameters
    //

    // Controls randomness: lowering results in less random completions.
    // As the temperature approaches zero, the model will become deterministic
    // and repetitive.
    temperature: 0.5,

    // The maximum number of tokens to generate. Requests can use up to
    // 2048 tokens shared between prompt and completion.
    max_tokens: 1024,

    // Controls diversity via nucleus sampling: 0.5 means half of all
    // likelihood-weighted options are considered.
    top_p: 1,

    // A stop sequence is a predefined or user-specified text string that
    // signals an AI to stop generating content, ensuring its responses
    // remain focused and concise. Examples include punctuation marks and
    // markers like "[end]".
    //
    // For this example, we will use ", 6" so that the llm stops counting at 5.
    // If multiple stop values are needed, an array of string may be passed,
    // stop: [", 6", ", six", ", Six"]
    stop: ', 6',

    // If set, partial message deltas will be sent.
    stream: true,
  });
  for await (const chunk of stream) {
    process.stdout.write(chunk.choices[0]?.delta?.content || '');
  }
}

main();



================================================
FILE: examples/chat_completion_streaming.js
================================================
const Groq = require('groq-sdk');

const groq = new Groq();

async function main() {
  const stream = await groq.chat.completions.create({
    //
    // Required parameters
    //
    messages: [
      // Set an optional system message. This sets the behavior of the
      // assistant and can be used to provide specific instructions for
      // how it should behave throughout the conversation.
      {
        role: 'system',
        content: 'you are a helpful assistant.',
      },
      // Set a user message for the assistant to respond to.
      {
        role: 'user',
        content: 'Explain the importance of low latency LLMs',
      },
    ],

    // The language model which will generate the completion.
    model: 'mixtral-8x7b-32768',

    //
    // Optional parameters
    //

    // Controls randomness: lowering results in less random completions.
    // As the temperature approaches zero, the model will become deterministic
    // and repetitive.
    temperature: 0.5,

    // The maximum number of tokens to generate. Requests can use up to
    // 2048 tokens shared between prompt and completion.
    max_tokens: 1024,

    // Controls diversity via nucleus sampling: 0.5 means half of all
    // likelihood-weighted options are considered.
    top_p: 1,

    // A stop sequence is a predefined or user-specified text string that
    // signals an AI to stop generating content, ensuring its responses
    // remain focused and concise. Examples include punctuation marks and
    // markers like "[end]".
    stop: null,

    // If set, partial message deltas will be sent.
    stream: true,
  });
  for await (const chunk of stream) {
    process.stdout.write(chunk.choices[0]?.delta?.content || '');
  }
}

main();



================================================
FILE: examples/.keep
================================================
File generated from our OpenAPI spec by Stainless.

This directory can be used to store example files demonstrating usage of this SDK.
It is ignored by Stainless code generation and its content (other than this keep file) won't be touched.



================================================
FILE: scripts/bootstrap
================================================
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

if [ -f "Brewfile" ] && [ "$(uname -s)" = "Darwin" ] && [ "$SKIP_BREW" != "1" ]; then
  brew bundle check >/dev/null 2>&1 || {
    echo "==> Installing Homebrew dependencies…"
    brew bundle
  }
fi

echo "==> Installing Node dependencies…"

PACKAGE_MANAGER=$(command -v yarn >/dev/null 2>&1 && echo "yarn" || echo "npm")

$PACKAGE_MANAGER install



================================================
FILE: scripts/format
================================================
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

echo "==> Running eslint --fix"
ESLINT_USE_FLAT_CONFIG="false" ./node_modules/.bin/eslint --fix --ext ts,js .



================================================
FILE: scripts/lint
================================================
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

echo "==> Running eslint"
ESLINT_USE_FLAT_CONFIG="false" ./node_modules/.bin/eslint --ext ts,js .

echo "==> Running tsc"
./node_modules/.bin/tsc --noEmit



================================================
FILE: scripts/mock
================================================
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

if [[ -n "$1" && "$1" != '--'* ]]; then
  URL="$1"
  shift
else
  URL="$(grep 'openapi_spec_url' .stats.yml | cut -d' ' -f2)"
fi

# Check if the URL is empty
if [ -z "$URL" ]; then
  echo "Error: No OpenAPI spec path/url provided or found in .stats.yml"
  exit 1
fi

echo "==> Starting mock server with URL ${URL}"

# Run prism mock on the given spec
if [ "$1" == "--daemon" ]; then
  npm exec --package=@stainless-api/prism-cli@5.15.0 -- prism mock "$URL" &> .prism.log &

  # Wait for server to come online
  echo -n "Waiting for server"
  while ! grep -q "✖  fatal\|Prism is listening" ".prism.log" ; do
    echo -n "."
    sleep 0.1
  done

  if grep -q "✖  fatal" ".prism.log"; then
    cat .prism.log
    exit 1
  fi

  echo
else
  npm exec --package=@stainless-api/prism-cli@5.15.0 -- prism mock "$URL"
fi



================================================
FILE: scripts/test
================================================
#!/usr/bin/env bash

set -e

cd "$(dirname "$0")/.."

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

function prism_is_running() {
  curl --silent "http://localhost:4010" >/dev/null 2>&1
}

kill_server_on_port() {
  pids=$(lsof -t -i tcp:"$1" || echo "")
  if [ "$pids" != "" ]; then
    kill "$pids"
    echo "Stopped $pids."
  fi
}

function is_overriding_api_base_url() {
  [ -n "$TEST_API_BASE_URL" ]
}

if ! is_overriding_api_base_url && ! prism_is_running ; then
  # When we exit this script, make sure to kill the background mock server process
  trap 'kill_server_on_port 4010' EXIT

  # Start the dev server
  ./scripts/mock --daemon
fi

if is_overriding_api_base_url ; then
  echo -e "${GREEN}✔ Running tests against ${TEST_API_BASE_URL}${NC}"
  echo
elif ! prism_is_running ; then
  echo -e "${RED}ERROR:${NC} The test suite will not run without a mock Prism server"
  echo -e "running against your OpenAPI spec."
  echo
  echo -e "To run the server, pass in the path or url of your OpenAPI"
  echo -e "spec to the prism command:"
  echo
  echo -e "  \$ ${YELLOW}npm exec --package=@stainless-api/prism-cli@5.15.0 -- prism mock path/to/your.openapi.yml${NC}"
  echo

  exit 1
else
  echo -e "${GREEN}✔ Mock prism server is running with your OpenAPI spec${NC}"
  echo
fi

echo "==> Running tests"
./node_modules/.bin/jest "$@"



================================================
FILE: scripts/utils/check-is-in-git-install.sh
================================================
#!/usr/bin/env bash
# Check if you happen to call prepare for a repository that's already in node_modules.
[ "$(basename "$(dirname "$PWD")")" = 'node_modules' ] ||
# The name of the containing directory that 'npm` uses, which looks like
# $HOME/.npm/_cacache/git-cloneXXXXXX
[ "$(basename "$(dirname "$PWD")")" = 'tmp' ] ||
# The name of the containing directory that 'yarn` uses, which looks like
# $(yarn cache dir)/.tmp/XXXXX
[ "$(basename "$(dirname "$PWD")")" = '.tmp' ]



================================================
FILE: scripts/utils/check-version.cjs
================================================
const fs = require('fs');
const path = require('path');

const main = () => {
  const pkg = require('../../package.json');
  const version = pkg['version'];
  if (!version) throw 'The version property is not set in the package.json file';
  if (typeof version !== 'string') {
    throw `Unexpected type for the package.json version field; got ${typeof version}, expected string`;
  }

  const versionFile = path.resolve(__dirname, '..', '..', 'src', 'version.ts');
  const contents = fs.readFileSync(versionFile, 'utf8');
  const output = contents.replace(/(export const VERSION = ')(.*)(')/g, `$1${version}$3`);
  fs.writeFileSync(versionFile, output);
};

if (require.main === module) {
  main();
}



================================================
FILE: scripts/utils/fix-index-exports.cjs
================================================
const fs = require('fs');
const path = require('path');

const indexJs =
  process.env['DIST_PATH'] ?
    path.resolve(process.env['DIST_PATH'], 'index.js')
  : path.resolve(__dirname, '..', '..', 'dist', 'index.js');

let before = fs.readFileSync(indexJs, 'utf8');
let after = before.replace(
  /^\s*exports\.default\s*=\s*(\w+)/m,
  'exports = module.exports = $1;\nexports.default = $1',
);
fs.writeFileSync(indexJs, after, 'utf8');



================================================
FILE: scripts/utils/git-swap.sh
================================================
#!/usr/bin/env bash
set -exuo pipefail
# the package is published to NPM from ./dist
# we want the final file structure for git installs to match the npm installs, so we

# delete everything except ./dist and ./node_modules
find . -maxdepth 1 -mindepth 1 ! -name 'dist' ! -name 'node_modules' -exec rm -rf '{}' +

# move everything from ./dist to .
mv dist/* .

# delete the now-empty ./dist
rmdir dist



================================================
FILE: scripts/utils/make-dist-package-json.cjs
================================================
const pkgJson = require(process.env['PKG_JSON_PATH'] || '../../package.json');

function processExportMap(m) {
  for (const key in m) {
    const value = m[key];
    if (typeof value === 'string') m[key] = value.replace(/^\.\/dist\//, './');
    else processExportMap(value);
  }
}
processExportMap(pkgJson.exports);

for (const key of ['types', 'main', 'module']) {
  if (typeof pkgJson[key] === 'string') pkgJson[key] = pkgJson[key].replace(/^(\.\/)?dist\//, './');
}

delete pkgJson.devDependencies;
delete pkgJson.scripts.prepack;
delete pkgJson.scripts.prepublishOnly;
delete pkgJson.scripts.prepare;

console.log(JSON.stringify(pkgJson, null, 2));



================================================
FILE: scripts/utils/postprocess-files.cjs
================================================
const fs = require('fs');
const path = require('path');
const { parse } = require('@typescript-eslint/parser');

const pkgImportPath = process.env['PKG_IMPORT_PATH'] ?? 'groq-sdk/';

const distDir =
  process.env['DIST_PATH'] ?
    path.resolve(process.env['DIST_PATH'])
  : path.resolve(__dirname, '..', '..', 'dist');
const distSrcDir = path.join(distDir, 'src');

/**
 * Quick and dirty AST traversal
 */
function traverse(node, visitor) {
  if (!node || typeof node.type !== 'string') return;
  visitor.node?.(node);
  visitor[node.type]?.(node);
  for (const key in node) {
    const value = node[key];
    if (Array.isArray(value)) {
      for (const elem of value) traverse(elem, visitor);
    } else if (value instanceof Object) {
      traverse(value, visitor);
    }
  }
}

/**
 * Helper method for replacing arbitrary ranges of text in input code.
 *
 * The `replacer` is a function that will be called with a mini-api.  For example:
 *
 * replaceRanges('foobar', ({ replace }) => replace([0, 3], 'baz')) // 'bazbar'
 *
 * The replaced ranges must not be overlapping.
 */
function replaceRanges(code, replacer) {
  const replacements = [];
  replacer({ replace: (range, replacement) => replacements.push({ range, replacement }) });

  if (!replacements.length) return code;
  replacements.sort((a, b) => a.range[0] - b.range[0]);
  const overlapIndex = replacements.findIndex(
    (r, index) => index > 0 && replacements[index - 1].range[1] > r.range[0],
  );
  if (overlapIndex >= 0) {
    throw new Error(
      `replacements overlap: ${JSON.stringify(replacements[overlapIndex - 1])} and ${JSON.stringify(
        replacements[overlapIndex],
      )}`,
    );
  }

  const parts = [];
  let end = 0;
  for (const {
    range: [from, to],
    replacement,
  } of replacements) {
    if (from > end) parts.push(code.substring(end, from));
    parts.push(replacement);
    end = to;
  }
  if (end < code.length) parts.push(code.substring(end));
  return parts.join('');
}

/**
 * Like calling .map(), where the iteratee is called on the path in every import or export from statement.
 * @returns the transformed code
 */
function mapModulePaths(code, iteratee) {
  const ast = parse(code, { range: true });
  return replaceRanges(code, ({ replace }) =>
    traverse(ast, {
      node(node) {
        switch (node.type) {
          case 'ImportDeclaration':
          case 'ExportNamedDeclaration':
          case 'ExportAllDeclaration':
          case 'ImportExpression':
            if (node.source) {
              const { range, value } = node.source;
              const transformed = iteratee(value);
              if (transformed !== value) {
                replace(range, JSON.stringify(transformed));
              }
            }
        }
      },
    }),
  );
}

async function* walk(dir) {
  for await (const d of await fs.promises.opendir(dir)) {
    const entry = path.join(dir, d.name);
    if (d.isDirectory()) yield* walk(entry);
    else if (d.isFile()) yield entry;
  }
}

async function postprocess() {
  for await (const file of walk(path.resolve(__dirname, '..', '..', 'dist'))) {
    if (!/\.([cm]?js|(\.d)?[cm]?ts)$/.test(file)) continue;

    const code = await fs.promises.readFile(file, 'utf8');

    let transformed = mapModulePaths(code, (importPath) => {
      if (file.startsWith(distSrcDir)) {
        if (importPath.startsWith(pkgImportPath)) {
          // convert self-references in dist/src to relative paths
          let relativePath = path.relative(
            path.dirname(file),
            path.join(distSrcDir, importPath.substring(pkgImportPath.length)),
          );
          if (!relativePath.startsWith('.')) relativePath = `./${relativePath}`;
          return relativePath;
        }
        return importPath;
      }
      if (importPath.startsWith('.')) {
        // add explicit file extensions to relative imports
        const { dir, name } = path.parse(importPath);
        const ext = /\.mjs$/.test(file) ? '.mjs' : '.js';
        return `${dir}/${name}${ext}`;
      }
      return importPath;
    });

    if (file.startsWith(distSrcDir) && !file.endsWith('_shims/index.d.ts')) {
      // strip out `unknown extends Foo ? never :` shim guards in dist/src
      // to prevent errors from appearing in Go To Source
      transformed = transformed.replace(
        new RegExp('unknown extends (typeof )?\\S+ \\? \\S+ :\\s*'.replace(/\s+/, '\\s+'), 'gm'),
        // replace with same number of characters to avoid breaking source maps
        (match) => ' '.repeat(match.length),
      );
    }

    if (file.endsWith('.d.ts')) {
      // work around bad tsc behavior
      // if we have `import { type Readable } from 'groq-sdk/_shims/index'`,
      // tsc sometimes replaces `Readable` with `import("stream").Readable` inline
      // in the output .d.ts
      transformed = transformed.replace(/import\("stream"\).Readable/g, 'Readable');
    }

    // strip out lib="dom" and types="node" references; these are needed at build time,
    // but would pollute the user's TS environment
    transformed = transformed.replace(
      /^ *\/\/\/ *<reference +(lib="dom"|types="node").*?\n/gm,
      // replace with same number of characters to avoid breaking source maps
      (match) => ' '.repeat(match.length - 1) + '\n',
    );

    if (transformed !== code) {
      await fs.promises.writeFile(file, transformed, 'utf8');
      console.error(`wrote ${path.relative(process.cwd(), file)}`);
    }
  }
}
postprocess();



================================================
FILE: scripts/utils/upload-artifact.sh
================================================
#!/usr/bin/env bash
set -exuo pipefail

RESPONSE=$(curl -X POST "$URL" \
  -H "Authorization: Bearer $AUTH" \
  -H "Content-Type: application/json")

SIGNED_URL=$(echo "$RESPONSE" | jq -r '.url')

if [[ "$SIGNED_URL" == "null" ]]; then
  echo -e "\033[31mFailed to get signed URL.\033[0m"
  exit 1
fi

UPLOAD_RESPONSE=$(tar -cz "${BUILD_PATH:-dist}" | curl -v -X PUT \
  -H "Content-Type: application/gzip" \
  --data-binary @- "$SIGNED_URL" 2>&1)

if echo "$UPLOAD_RESPONSE" | grep -q "HTTP/[0-9.]* 200"; then
  echo -e "\033[32mUploaded build to Stainless storage.\033[0m"
  echo -e "\033[32mInstallation: npm install 'https://pkg.stainless.com/s/groqcloud-node/$SHA'\033[0m"
else
  echo -e "\033[31mFailed to upload artifact.\033[0m"
  exit 1
fi



================================================
FILE: src/core.ts
================================================
import { VERSION } from './version';
import { Stream } from './lib/streaming';
import {
  GroqError,
  APIError,
  APIConnectionError,
  APIConnectionTimeoutError,
  APIUserAbortError,
} from './error';
import {
  kind as shimsKind,
  type Readable,
  getDefaultAgent,
  type Agent,
  fetch,
  type RequestInfo,
  type RequestInit,
  type Response,
  type HeadersInit,
  init,
} from './_shims/index';

// try running side effects outside of _shims/index to workaround https://github.com/vercel/next.js/issues/76881
init();

export { type Response };
import { BlobLike, isBlobLike, isMultipartBody } from './uploads';
export {
  maybeMultipartFormRequestOptions,
  multipartFormRequestOptions,
  createForm,
  type Uploadable,
} from './uploads';

export type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;

/**
 * An alias to the builtin `Array` type so we can
 * easily alias it in import statements if there are name clashes.
 */
type _Array<T> = Array<T>;

/**
 * An alias to the builtin `Record` type so we can
 * easily alias it in import statements if there are name clashes.
 */
type _Record<K extends keyof any, T> = Record<K, T>;

export type { _Array as Array, _Record as Record };

type PromiseOrValue<T> = T | Promise<T>;

type APIResponseProps = {
  response: Response;
  options: FinalRequestOptions;
  controller: AbortController;
};

async function defaultParseResponse<T>(props: APIResponseProps): Promise<T> {
  const { response } = props;
  if (props.options.stream) {
    debug('response', response.status, response.url, response.headers, response.body);

    // Note: there is an invariant here that isn't represented in the type system
    // that if you set `stream: true` the response type must also be `Stream<T>`

    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller) as any;
    }

    return Stream.fromSSEResponse(response, props.controller) as any;
  }

  // fetch refuses to read the body when the status code is 204.
  if (response.status === 204) {
    return null as T;
  }

  if (props.options.__binaryResponse) {
    return response as unknown as T;
  }

  const contentType = response.headers.get('content-type');
  const mediaType = contentType?.split(';')[0]?.trim();
  const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');
  if (isJSON) {
    const json = await response.json();

    debug('response', response.status, response.url, response.headers, json);

    return json as T;
  }

  const text = await response.text();
  debug('response', response.status, response.url, response.headers, text);

  // TODO handle blob, arraybuffer, other content types, etc.
  return text as unknown as T;
}

/**
 * A subclass of `Promise` providing additional helper methods
 * for interacting with the SDK.
 */
export class APIPromise<T> extends Promise<T> {
  private parsedPromise: Promise<T> | undefined;

  constructor(
    private responsePromise: Promise<APIResponseProps>,
    private parseResponse: (props: APIResponseProps) => PromiseOrValue<T> = defaultParseResponse,
  ) {
    super((resolve) => {
      // this is maybe a bit weird but this has to be a no-op to not implicitly
      // parse the response body; instead .then, .catch, .finally are overridden
      // to parse the response
      resolve(null as any);
    });
  }

  _thenUnwrap<U>(transform: (data: T, props: APIResponseProps) => U): APIPromise<U> {
    return new APIPromise(this.responsePromise, async (props) =>
      transform(await this.parseResponse(props), props),
    );
  }

  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  asResponse(): Promise<Response> {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  async withResponse(): Promise<{ data: T; response: Response }> {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }

  private parse(): Promise<T> {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }

  override then<TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
  ): Promise<TResult1 | TResult2> {
    return this.parse().then(onfulfilled, onrejected);
  }

  override catch<TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
  ): Promise<T | TResult> {
    return this.parse().catch(onrejected);
  }

  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {
    return this.parse().finally(onfinally);
  }
}

export abstract class APIClient {
  baseURL: string;
  #baseURLOverridden: boolean;
  maxRetries: number;
  timeout: number;
  httpAgent: Agent | undefined;

  private fetch: Fetch;
  protected idempotencyHeader?: string;

  constructor({
    baseURL,
    baseURLOverridden,
    maxRetries = 2,
    timeout = 60000, // 1 minute
    httpAgent,
    fetch: overriddenFetch,
  }: {
    baseURL: string;
    baseURLOverridden: boolean;
    maxRetries?: number | undefined;
    timeout: number | undefined;
    httpAgent: Agent | undefined;
    fetch: Fetch | undefined;
  }) {
    this.baseURL = baseURL;
    this.#baseURLOverridden = baseURLOverridden;
    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);
    this.timeout = validatePositiveInteger('timeout', timeout);
    this.httpAgent = httpAgent;

    this.fetch = overriddenFetch ?? fetch;
  }

  protected authHeaders(opts: FinalRequestOptions): Headers {
    return {};
  }

  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  protected defaultHeaders(opts: FinalRequestOptions): Headers {
    return {
      Accept: 'application/json',
      ...(['head', 'get'].includes(opts.method) ? {} : { 'Content-Type': 'application/json' }),
      'User-Agent': this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts),
    };
  }

  protected abstract defaultQuery(): DefaultQuery | undefined;

  /**
   * Override this to add your own headers validation:
   */
  protected validateHeaders(headers: Headers, customHeaders: Headers) {}

  protected defaultIdempotencyKey(): string {
    return `stainless-node-retry-${uuid4()}`;
  }

  get<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {
    return this.methodRequest('get', path, opts);
  }

  post<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {
    return this.methodRequest('post', path, opts);
  }

  patch<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {
    return this.methodRequest('patch', path, opts);
  }

  put<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {
    return this.methodRequest('put', path, opts);
  }

  delete<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {
    return this.methodRequest('delete', path, opts);
  }

  private methodRequest<Req, Rsp>(
    method: HTTPMethod,
    path: string,
    opts?: PromiseOrValue<RequestOptions<Req>>,
  ): APIPromise<Rsp> {
    return this.request(
      Promise.resolve(opts).then(async (opts) => {
        const body =
          opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())
          : opts?.body instanceof DataView ? opts.body
          : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)
          : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)
          : opts?.body;
        return { method, path, ...opts, body };
      }),
    );
  }

  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(
    path: string,
    Page: new (...args: any[]) => PageClass,
    opts?: RequestOptions<any>,
  ): PagePromise<PageClass, Item> {
    return this.requestAPIList(Page, { method: 'get', path, ...opts });
  }

  private calculateContentLength(body: unknown): string | null {
    if (typeof body === 'string') {
      if (typeof Buffer !== 'undefined') {
        return Buffer.byteLength(body, 'utf8').toString();
      }

      if (typeof TextEncoder !== 'undefined') {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }

    return null;
  }

  async buildRequest<Req>(
    inputOptions: FinalRequestOptions<Req>,
    { retryCount = 0 }: { retryCount?: number } = {},
  ): Promise<{ req: RequestInit; url: string; timeout: number }> {
    const options = { ...inputOptions };
    const { method, path, query, defaultBaseURL, headers: headers = {} } = options;

    const body =
      ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?
        options.body
      : isMultipartBody(options.body) ? options.body.body
      : options.body ? JSON.stringify(options.body, null, 2)
      : null;
    const contentLength = this.calculateContentLength(body);

    const url = this.buildURL(path!, query, defaultBaseURL);
    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = options.timeout + 1000;
    if (
      typeof (httpAgent as any)?.options?.timeout === 'number' &&
      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)
    ) {
      // Allow any given request to bump our agent active socket timeout.
      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,
      // and without mutating agent we would need to create more of them.
      // This tradeoff optimizes for performance.
      (httpAgent as any).options.timeout = minAgentTimeout;
    }

    if (this.idempotencyHeader && method !== 'get') {
      if (!inputOptions.idempotencyKey) inputOptions.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = inputOptions.idempotencyKey;
    }

    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });

    const req: RequestInit = {
      method,
      ...(body && { body: body as any }),
      headers: reqHeaders,
      ...(httpAgent && { agent: httpAgent }),
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null,
    };

    return { req, url, timeout: options.timeout };
  }

  private buildHeaders({
    options,
    headers,
    contentLength,
    retryCount,
  }: {
    options: FinalRequestOptions;
    headers: Record<string, string | null | undefined>;
    contentLength: string | null | undefined;
    retryCount: number;
  }): Record<string, string> {
    const reqHeaders: Record<string, string> = {};
    if (contentLength) {
      reqHeaders['content-length'] = contentLength;
    }

    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);

    // let builtin fetch set the Content-Type for multipart bodies
    if (isMultipartBody(options.body) && shimsKind !== 'node') {
      delete reqHeaders['content-type'];
    }

    // Don't set theses headers if they were already set or removed through default headers or by the caller.
    // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account
    // for the removal case.
    if (
      getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&
      getHeader(headers, 'x-stainless-retry-count') === undefined
    ) {
      reqHeaders['x-stainless-retry-count'] = String(retryCount);
    }
    if (
      getHeader(defaultHeaders, 'x-stainless-timeout') === undefined &&
      getHeader(headers, 'x-stainless-timeout') === undefined &&
      options.timeout
    ) {
      reqHeaders['x-stainless-timeout'] = String(Math.trunc(options.timeout / 1000));
    }

    this.validateHeaders(reqHeaders, headers);

    return reqHeaders;
  }

  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  protected async prepareOptions(options: FinalRequestOptions): Promise<void> {}

  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  protected async prepareRequest(
    request: RequestInit,
    { url, options }: { url: string; options: FinalRequestOptions },
  ): Promise<void> {}

  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string> {
    return (
      !headers ? {}
      : Symbol.iterator in headers ?
        Object.fromEntries(Array.from(headers as Iterable<string[]>).map((header) => [...header]))
      : { ...(headers as any as Record<string, string>) }
    );
  }

  protected makeStatusError(
    status: number | undefined,
    error: Object | undefined,
    message: string | undefined,
    headers: Headers | undefined,
  ): APIError {
    return APIError.generate(status, error, message, headers);
  }

  request<Req, Rsp>(
    options: PromiseOrValue<FinalRequestOptions<Req>>,
    remainingRetries: number | null = null,
  ): APIPromise<Rsp> {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }

  private async makeRequest<Req>(
    optionsInput: PromiseOrValue<FinalRequestOptions<Req>>,
    retriesRemaining: number | null,
  ): Promise<APIResponseProps> {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }

    await this.prepareOptions(options);

    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining,
    });

    await this.prepareRequest(req, { url, options });

    debug('request', url, options, req.headers);

    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }

    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);

    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === 'AbortError') {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }

    const responseHeaders = createResponseHeaders(response.headers);

    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }

      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? undefined : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;

      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);

      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }

    return { response, options, controller };
  }

  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(
    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,
    options: FinalRequestOptions,
  ): PagePromise<PageClass, Item> {
    const request = this.makeRequest(options, null);
    return new PagePromise<PageClass, Item>(this, request, Page);
  }

  buildURL<Req>(path: string, query: Req | null | undefined, defaultBaseURL?: string | undefined): string {
    const baseURL = (!this.#baseURLOverridden && defaultBaseURL) || this.baseURL;
    const url =
      isAbsoluteURL(path) ?
        new URL(path)
      : new URL(baseURL + (baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));

    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query } as Req;
    }

    if (typeof query === 'object' && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query as Record<string, unknown>);
    }

    return url.toString();
  }

  protected stringifyQuery(query: Record<string, unknown>): string {
    return Object.entries(query)
      .filter(([_, value]) => typeof value !== 'undefined')
      .map(([key, value]) => {
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
        }
        if (value === null) {
          return `${encodeURIComponent(key)}=`;
        }
        throw new GroqError(
          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,
        );
      })
      .join('&');
  }

  async fetchWithTimeout(
    url: RequestInfo,
    init: RequestInit | undefined,
    ms: number,
    controller: AbortController,
  ): Promise<Response> {
    const { signal, ...options } = init || {};
    if (signal) signal.addEventListener('abort', () => controller.abort());

    const timeout = setTimeout(() => controller.abort(), ms);

    const fetchOptions = {
      signal: controller.signal as any,
      ...options,
    };
    if (fetchOptions.method) {
      // Custom methods like 'patch' need to be uppercased
      // See https://github.com/nodejs/undici/issues/2294
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }

    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(undefined, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }

  private shouldRetry(response: Response): boolean {
    // Note this is not a standard header.
    const shouldRetryHeader = response.headers.get('x-should-retry');

    // If the server explicitly says whether or not to retry, obey.
    if (shouldRetryHeader === 'true') return true;
    if (shouldRetryHeader === 'false') return false;

    // Retry on request timeouts.
    if (response.status === 408) return true;

    // Retry on lock timeouts.
    if (response.status === 409) return true;

    // Retry on rate limits.
    if (response.status === 429) return true;

    // Retry internal errors.
    if (response.status >= 500) return true;

    return false;
  }

  private async retryRequest(
    options: FinalRequestOptions,
    retriesRemaining: number,
    responseHeaders?: Headers | undefined,
  ): Promise<APIResponseProps> {
    let timeoutMillis: number | undefined;

    // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.
    const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }

    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
    const retryAfterHeader = responseHeaders?.['retry-after'];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1000;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }

    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),
    // just do what it says, but otherwise calculate a default
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);

    return this.makeRequest(options, retriesRemaining - 1);
  }

  private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8.0;

    const numRetries = maxRetries - retriesRemaining;

    // Apply exponential backoff, but not more than the max.
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);

    // Apply some jitter, take up to at most 25 percent of the retry time.
    const jitter = 1 - Math.random() * 0.25;

    return sleepSeconds * jitter * 1000;
  }

  private getUserAgent(): string {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
}

export type PageInfo = { url: URL } | { params: Record<string, unknown> | null };

export abstract class AbstractPage<Item> implements AsyncIterable<Item> {
  #client: APIClient;
  protected options: FinalRequestOptions;

  protected response: Response;
  protected body: unknown;

  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {
    this.#client = client;
    this.options = options;
    this.response = response;
    this.body = body;
  }

  /**
   * @deprecated Use nextPageInfo instead
   */
  abstract nextPageParams(): Partial<Record<string, unknown>> | null;
  abstract nextPageInfo(): PageInfo | null;

  abstract getPaginatedItems(): Item[];

  hasNextPage(): boolean {
    const items = this.getPaginatedItems();
    if (!items.length) return false;
    return this.nextPageInfo() != null;
  }

  async getNextPage(): Promise<this> {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new GroqError(
        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',
      );
    }
    const nextOptions = { ...this.options };
    if ('params' in nextInfo && typeof nextOptions.query === 'object') {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ('url' in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value as any);
      }
      nextOptions.query = undefined;
      nextOptions.path = nextInfo.url.toString();
    }
    return await this.#client.requestAPIList(this.constructor as any, nextOptions);
  }

  async *iterPages(): AsyncGenerator<this> {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let page: this = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }

  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}

/**
 * This subclass of Promise will resolve to an instantiated Page once the request completes.
 *
 * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:
 *
 *    for await (const item of client.items.list()) {
 *      console.log(item)
 *    }
 */
export class PagePromise<
    PageClass extends AbstractPage<Item>,
    Item = ReturnType<PageClass['getPaginatedItems']>[number],
  >
  extends APIPromise<PageClass>
  implements AsyncIterable<Item>
{
  constructor(
    client: APIClient,
    request: Promise<APIResponseProps>,
    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,
  ) {
    super(
      request,
      async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options),
    );
  }

  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}

export const createResponseHeaders = (
  headers: Awaited<ReturnType<Fetch>>['headers'],
): Record<string, string> => {
  return new Proxy(
    Object.fromEntries(
      // @ts-ignore
      headers.entries(),
    ),
    {
      get(target, name) {
        const key = name.toString();
        return target[key.toLowerCase()] || target[key];
      },
    },
  );
};

type HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';

export type RequestClient = { fetch: Fetch };
export type Headers = Record<string, string | null | undefined>;
export type DefaultQuery = Record<string, string | undefined>;
export type KeysEnum<T> = { [P in keyof Required<T>]: true };

export type RequestOptions<
  Req = unknown | Record<string, unknown> | Readable | BlobLike | ArrayBufferView | ArrayBuffer,
> = {
  method?: HTTPMethod;
  path?: string;
  query?: Req | undefined;
  body?: Req | null | undefined;
  headers?: Headers | undefined;
  defaultBaseURL?: string | undefined;

  maxRetries?: number;
  stream?: boolean | undefined;
  timeout?: number;
  httpAgent?: Agent;
  signal?: AbortSignal | undefined | null;
  idempotencyKey?: string;

  __binaryRequest?: boolean | undefined;
  __binaryResponse?: boolean | undefined;
  __streamClass?: typeof Stream;
};

// This is required so that we can determine if a given object matches the RequestOptions
// type at runtime. While this requires duplication, it is enforced by the TypeScript
// compiler such that any missing / extraneous keys will cause an error.
const requestOptionsKeys: KeysEnum<RequestOptions> = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  defaultBaseURL: true,

  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,

  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true,
};

export const isRequestOptions = (obj: unknown): obj is RequestOptions => {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    !isEmptyObj(obj) &&
    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))
  );
};

export type FinalRequestOptions<Req = unknown | Record<string, unknown> | Readable | DataView> =
  RequestOptions<Req> & {
    method: HTTPMethod;
    path: string;
  };

declare const Deno: any;
declare const EdgeRuntime: any;
type Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';
type PlatformName =
  | 'MacOS'
  | 'Linux'
  | 'Windows'
  | 'FreeBSD'
  | 'OpenBSD'
  | 'iOS'
  | 'Android'
  | `Other:${string}`
  | 'Unknown';
type Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';
type PlatformProperties = {
  'X-Stainless-Lang': 'js';
  'X-Stainless-Package-Version': string;
  'X-Stainless-OS': PlatformName;
  'X-Stainless-Arch': Arch;
  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';
  'X-Stainless-Runtime-Version': string;
};
const getPlatformProperties = (): PlatformProperties => {
  if (typeof Deno !== 'undefined' && Deno.build != null) {
    return {
      'X-Stainless-Lang': 'js',
      'X-Stainless-Package-Version': VERSION,
      'X-Stainless-OS': normalizePlatform(Deno.build.os),
      'X-Stainless-Arch': normalizeArch(Deno.build.arch),
      'X-Stainless-Runtime': 'deno',
      'X-Stainless-Runtime-Version':
        typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',
    };
  }
  if (typeof EdgeRuntime !== 'undefined') {
    return {
      'X-Stainless-Lang': 'js',
      'X-Stainless-Package-Version': VERSION,
      'X-Stainless-OS': 'Unknown',
      'X-Stainless-Arch': `other:${EdgeRuntime}`,
      'X-Stainless-Runtime': 'edge',
      'X-Stainless-Runtime-Version': process.version,
    };
  }
  // Check if Node.js
  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {
    return {
      'X-Stainless-Lang': 'js',
      'X-Stainless-Package-Version': VERSION,
      'X-Stainless-OS': normalizePlatform(process.platform),
      'X-Stainless-Arch': normalizeArch(process.arch),
      'X-Stainless-Runtime': 'node',
      'X-Stainless-Runtime-Version': process.version,
    };
  }

  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      'X-Stainless-Lang': 'js',
      'X-Stainless-Package-Version': VERSION,
      'X-Stainless-OS': 'Unknown',
      'X-Stainless-Arch': 'unknown',
      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,
      'X-Stainless-Runtime-Version': browserInfo.version,
    };
  }

  // TODO add support for Cloudflare workers, etc.
  return {
    'X-Stainless-Lang': 'js',
    'X-Stainless-Package-Version': VERSION,
    'X-Stainless-OS': 'Unknown',
    'X-Stainless-Arch': 'unknown',
    'X-Stainless-Runtime': 'unknown',
    'X-Stainless-Runtime-Version': 'unknown',
  };
};

type BrowserInfo = {
  browser: Browser;
  version: string;
};

declare const navigator: { userAgent: string } | undefined;

// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts
function getBrowserInfo(): BrowserInfo | null {
  if (typeof navigator === 'undefined' || !navigator) {
    return null;
  }

  // NOTE: The order matters here!
  const browserPatterns = [
    { key: 'edge' as const, pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'ie' as const, pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'ie' as const, pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'chrome' as const, pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'firefox' as const, pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: 'safari' as const, pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ },
  ];

  // Find the FIRST matching browser
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;

      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }

  return null;
}

const normalizeArch = (arch: string): Arch => {
  // Node docs:
  // - https://nodejs.org/api/process.html#processarch
  // Deno docs:
  // - https://doc.deno.land/deno/stable/~/Deno.build
  if (arch === 'x32') return 'x32';
  if (arch === 'x86_64' || arch === 'x64') return 'x64';
  if (arch === 'arm') return 'arm';
  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';
  if (arch) return `other:${arch}`;
  return 'unknown';
};

const normalizePlatform = (platform: string): PlatformName => {
  // Node platforms:
  // - https://nodejs.org/api/process.html#processplatform
  // Deno platforms:
  // - https://doc.deno.land/deno/stable/~/Deno.build
  // - https://github.com/denoland/deno/issues/14799

  platform = platform.toLowerCase();

  // NOTE: this iOS check is untested and may not work
  // Node does not work natively on IOS, there is a fork at
  // https://github.com/nodejs-mobile/nodejs-mobile
  // however it is unknown at the time of writing how to detect if it is running
  if (platform.includes('ios')) return 'iOS';
  if (platform === 'android') return 'Android';
  if (platform === 'darwin') return 'MacOS';
  if (platform === 'win32') return 'Windows';
  if (platform === 'freebsd') return 'FreeBSD';
  if (platform === 'openbsd') return 'OpenBSD';
  if (platform === 'linux') return 'Linux';
  if (platform) return `Other:${platform}`;
  return 'Unknown';
};

let _platformHeaders: PlatformProperties;
const getPlatformHeaders = () => {
  return (_platformHeaders ??= getPlatformProperties());
};

export const safeJSON = (text: string) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return undefined;
  }
};

// https://url.spec.whatwg.org/#url-scheme-string
const startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
const isAbsoluteURL = (url: string): boolean => {
  return startsWithSchemeRegexp.test(url);
};

export const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

const validatePositiveInteger = (name: string, n: unknown): number => {
  if (typeof n !== 'number' || !Number.isInteger(n)) {
    throw new GroqError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new GroqError(`${name} must be a positive integer`);
  }
  return n;
};

export const castToError = (err: any): Error => {
  if (err instanceof Error) return err;
  if (typeof err === 'object' && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {}
  }
  return new Error(err);
};

export const ensurePresent = <T>(value: T | null | undefined): T => {
  if (value == null) throw new GroqError(`Expected a value to be given but received ${value} instead.`);
  return value;
};

/**
 * Read an environment variable.
 *
 * Trims beginning and trailing whitespace.
 *
 * Will return undefined if the environment variable doesn't exist or cannot be accessed.
 */
export const readEnv = (env: string): string | undefined => {
  if (typeof process !== 'undefined') {
    return process.env?.[env]?.trim() ?? undefined;
  }
  if (typeof Deno !== 'undefined') {
    return Deno.env?.get?.(env)?.trim();
  }
  return undefined;
};

export const coerceInteger = (value: unknown): number => {
  if (typeof value === 'number') return Math.round(value);
  if (typeof value === 'string') return parseInt(value, 10);

  throw new GroqError(`Could not coerce ${value} (type: ${typeof value}) into a number`);
};

export const coerceFloat = (value: unknown): number => {
  if (typeof value === 'number') return value;
  if (typeof value === 'string') return parseFloat(value);

  throw new GroqError(`Could not coerce ${value} (type: ${typeof value}) into a number`);
};

export const coerceBoolean = (value: unknown): boolean => {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'string') return value === 'true';
  return Boolean(value);
};

export const maybeCoerceInteger = (value: unknown): number | undefined => {
  if (value === undefined) {
    return undefined;
  }
  return coerceInteger(value);
};

export const maybeCoerceFloat = (value: unknown): number | undefined => {
  if (value === undefined) {
    return undefined;
  }
  return coerceFloat(value);
};

export const maybeCoerceBoolean = (value: unknown): boolean | undefined => {
  if (value === undefined) {
    return undefined;
  }
  return coerceBoolean(value);
};

// https://stackoverflow.com/a/34491287
export function isEmptyObj(obj: Object | null | undefined): boolean {
  if (!obj) return true;
  for (const _k in obj) return false;
  return true;
}

// https://eslint.org/docs/latest/rules/no-prototype-builtins
export function hasOwn(obj: Object, key: string): boolean {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

/**
 * Copies headers from "newHeaders" onto "targetHeaders",
 * using lower-case for all properties,
 * ignoring any keys with undefined values,
 * and deleting any keys with null values.
 */
function applyHeadersMut(targetHeaders: Headers, newHeaders: Headers): void {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k)) continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey) continue;

    const val = newHeaders[k];

    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== undefined) {
      targetHeaders[lowerKey] = val;
    }
  }
}

export function debug(action: string, ...args: any[]) {
  if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {
    console.log(`Groq:DEBUG:${action}`, ...args);
  }
}

/**
 * https://stackoverflow.com/a/2117523
 */
const uuid4 = () => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
};

export const isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== 'undefined' &&
    // @ts-ignore
    typeof window.document !== 'undefined' &&
    // @ts-ignore
    typeof navigator !== 'undefined'
  );
};

export interface HeadersProtocol {
  get: (header: string) => string | null | undefined;
}
export type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;

export const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {
  return typeof headers?.get === 'function';
};

export const getRequiredHeader = (headers: HeadersLike | Headers, header: string): string => {
  const foundHeader = getHeader(headers, header);
  if (foundHeader === undefined) {
    throw new Error(`Could not find ${header} header`);
  }
  return foundHeader;
};

export const getHeader = (headers: HeadersLike | Headers, header: string): string | undefined => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    // to deal with the case where the header looks like Stainless-Event-Id
    const intercapsHeader =
      header[0]?.toUpperCase() +
      header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }

  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1) return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }

  return undefined;
};

/**
 * Encodes a string to Base64 format.
 */
export const toBase64 = (str: string | null | undefined): string => {
  if (!str) return '';
  if (typeof Buffer !== 'undefined') {
    return Buffer.from(str).toString('base64');
  }

  if (typeof btoa !== 'undefined') {
    return btoa(str);
  }

  throw new GroqError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');
};

export function isObj(obj: unknown): obj is Record<string, unknown> {
  return obj != null && typeof obj === 'object' && !Array.isArray(obj);
}



================================================
FILE: src/error.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { castToError, Headers } from './core';

export class GroqError extends Error {}

export class APIError<
  TStatus extends number | undefined = number | undefined,
  THeaders extends Headers | undefined = Headers | undefined,
  TError extends Object | undefined = Object | undefined,
> extends GroqError {
  /** HTTP status for the response that caused the error */
  readonly status: TStatus;
  /** HTTP headers for the response that caused the error */
  readonly headers: THeaders;
  /** JSON body of the response that caused the error */
  readonly error: TError;

  constructor(status: TStatus, error: TError, message: string | undefined, headers: THeaders) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.error = error;
  }

  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {
    const msg =
      error?.message ?
        typeof error.message === 'string' ?
          error.message
        : JSON.stringify(error.message)
      : error ? JSON.stringify(error)
      : message;

    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return '(no status code or body)';
  }

  static generate(
    status: number | undefined,
    errorResponse: Object | undefined,
    message: string | undefined,
    headers: Headers | undefined,
  ): APIError {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }

    const error = errorResponse as Record<string, any>;

    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }

    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }

    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }

    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }

    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }

    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }

    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }

    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }

    return new APIError(status, error, message, headers);
  }
}

export class APIUserAbortError extends APIError<undefined, undefined, undefined> {
  constructor({ message }: { message?: string } = {}) {
    super(undefined, undefined, message || 'Request was aborted.', undefined);
  }
}

export class APIConnectionError extends APIError<undefined, undefined, undefined> {
  constructor({ message, cause }: { message?: string | undefined; cause?: Error | undefined }) {
    super(undefined, undefined, message || 'Connection error.', undefined);
    // in some environments the 'cause' property is already declared
    // @ts-ignore
    if (cause) this.cause = cause;
  }
}

export class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message }: { message?: string } = {}) {
    super({ message: message ?? 'Request timed out.' });
  }
}

export class BadRequestError extends APIError<400, Headers> {}

export class AuthenticationError extends APIError<401, Headers> {}

export class PermissionDeniedError extends APIError<403, Headers> {}

export class NotFoundError extends APIError<404, Headers> {}

export class ConflictError extends APIError<409, Headers> {}

export class UnprocessableEntityError extends APIError<422, Headers> {}

export class RateLimitError extends APIError<429, Headers> {}

export class InternalServerError extends APIError<number, Headers> {}



================================================
FILE: src/index.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { type Agent } from './_shims/index';
import * as Core from './core';
import * as Errors from './error';
import * as Uploads from './uploads';
import * as API from './resources/index';
import {
  BatchCreateParams,
  BatchCreateResponse,
  BatchListResponse,
  BatchRetrieveResponse,
  Batches,
} from './resources/batches';
import { CompletionUsage, Completions } from './resources/completions';
import {
  CreateEmbeddingResponse,
  Embedding,
  EmbeddingCreateParams,
  Embeddings,
} from './resources/embeddings';
import {
  FileCreateParams,
  FileCreateResponse,
  FileDeleteResponse,
  FileInfoResponse,
  FileListResponse,
  Files,
} from './resources/files';
import { Model, ModelDeleted, ModelListResponse, Models } from './resources/models';
import { Audio } from './resources/audio/audio';
import { Chat } from './resources/chat/chat';

export interface ClientOptions {
  /**
   * Defaults to process.env['GROQ_API_KEY'].
   */
  apiKey?: string | undefined;

  /**
   * Override the default base URL for the API, e.g., "https://api.example.com/v2/"
   *
   * Defaults to process.env['GROQ_BASE_URL'].
   */
  baseURL?: string | null | undefined;

  /**
   * The maximum amount of time (in milliseconds) that the client should wait for a response
   * from the server before timing out a single request.
   *
   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait
   * much longer than this timeout before the promise succeeds or fails.
   *
   * @unit milliseconds
   */
  timeout?: number | undefined;

  /**
   * An HTTP agent used to manage HTTP(S) connections.
   *
   * If not provided, an agent will be constructed by default in the Node.js environment,
   * otherwise no agent is used.
   */
  httpAgent?: Agent | undefined;

  /**
   * Specify a custom `fetch` function implementation.
   *
   * If not provided, we use `node-fetch` on Node.js and otherwise expect that `fetch` is
   * defined globally.
   */
  fetch?: Core.Fetch | undefined;

  /**
   * The maximum number of times that the client will retry a request in case of a
   * temporary failure, like a network error or a 5XX error from the server.
   *
   * @default 2
   */
  maxRetries?: number | undefined;

  /**
   * Default headers to include with every request to the API.
   *
   * These can be removed in individual requests by explicitly setting the
   * header to `undefined` or `null` in request options.
   */
  defaultHeaders?: Core.Headers | undefined;

  /**
   * Default query parameters to include with every request to the API.
   *
   * These can be removed in individual requests by explicitly setting the
   * param to `undefined` in request options.
   */
  defaultQuery?: Core.DefaultQuery | undefined;

  /**
   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.
   */
  dangerouslyAllowBrowser?: boolean | undefined;
}

/**
 * API Client for interfacing with the Groq API.
 */
export class Groq extends Core.APIClient {
  apiKey: string;

  private _options: ClientOptions;

  /**
   * API Client for interfacing with the Groq API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['GROQ_API_KEY'] ?? undefined]
   * @param {string} [opts.baseURL=process.env['GROQ_BASE_URL'] ?? https://api.groq.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({
    baseURL = Core.readEnv('GROQ_BASE_URL'),
    apiKey = Core.readEnv('GROQ_API_KEY'),
    ...opts
  }: ClientOptions = {}) {
    if (apiKey === undefined) {
      throw new Errors.GroqError(
        "The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' }).",
      );
    }

    const options: ClientOptions = {
      apiKey,
      ...opts,
      baseURL: baseURL || `https://api.groq.com`,
    };

    if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {
      throw new Errors.GroqError(
        "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Groq({ apiKey, dangerouslyAllowBrowser: true })",
      );
    }

    super({
      baseURL: options.baseURL!,
      baseURLOverridden: baseURL ? baseURL !== 'https://api.groq.com' : false,
      timeout: options.timeout ?? 60000 /* 1 minute */,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch,
    });

    this._options = options;

    this.apiKey = apiKey;
  }

  completions: API.Completions = new API.Completions(this);
  chat: API.Chat = new API.Chat(this);
  embeddings: API.Embeddings = new API.Embeddings(this);
  audio: API.Audio = new API.Audio(this);
  models: API.Models = new API.Models(this);
  batches: API.Batches = new API.Batches(this);
  files: API.Files = new API.Files(this);

  /**
   * Check whether the base URL is set to its default.
   */
  #baseURLOverridden(): boolean {
    return this.baseURL !== 'https://api.groq.com';
  }

  protected override defaultQuery(): Core.DefaultQuery | undefined {
    return this._options.defaultQuery;
  }

  protected override defaultHeaders(opts: Core.FinalRequestOptions): Core.Headers {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.defaultHeaders,
    };
  }

  protected override authHeaders(opts: Core.FinalRequestOptions): Core.Headers {
    return { Authorization: `Bearer ${this.apiKey}` };
  }

  static Groq = this;
  static DEFAULT_TIMEOUT = 60000; // 1 minute

  static GroqError = Errors.GroqError;
  static APIError = Errors.APIError;
  static APIConnectionError = Errors.APIConnectionError;
  static APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;
  static APIUserAbortError = Errors.APIUserAbortError;
  static NotFoundError = Errors.NotFoundError;
  static ConflictError = Errors.ConflictError;
  static RateLimitError = Errors.RateLimitError;
  static BadRequestError = Errors.BadRequestError;
  static AuthenticationError = Errors.AuthenticationError;
  static InternalServerError = Errors.InternalServerError;
  static PermissionDeniedError = Errors.PermissionDeniedError;
  static UnprocessableEntityError = Errors.UnprocessableEntityError;

  static toFile = Uploads.toFile;
  static fileFromPath = Uploads.fileFromPath;
}

Groq.Completions = Completions;
Groq.Chat = Chat;
Groq.Embeddings = Embeddings;
Groq.Audio = Audio;
Groq.Models = Models;
Groq.Batches = Batches;
Groq.Files = Files;

export declare namespace Groq {
  export type RequestOptions = Core.RequestOptions;

  export { Completions as Completions, type CompletionUsage as CompletionUsage };

  export { Chat as Chat };

  export {
    Embeddings as Embeddings,
    type CreateEmbeddingResponse as CreateEmbeddingResponse,
    type Embedding as Embedding,
    type EmbeddingCreateParams as EmbeddingCreateParams,
  };

  export { Audio as Audio };

  export {
    Models as Models,
    type Model as Model,
    type ModelDeleted as ModelDeleted,
    type ModelListResponse as ModelListResponse,
  };

  export {
    Batches as Batches,
    type BatchCreateResponse as BatchCreateResponse,
    type BatchRetrieveResponse as BatchRetrieveResponse,
    type BatchListResponse as BatchListResponse,
    type BatchCreateParams as BatchCreateParams,
  };

  export {
    Files as Files,
    type FileCreateResponse as FileCreateResponse,
    type FileListResponse as FileListResponse,
    type FileDeleteResponse as FileDeleteResponse,
    type FileInfoResponse as FileInfoResponse,
    type FileCreateParams as FileCreateParams,
  };

  export type ErrorObject = API.ErrorObject;
  export type FunctionDefinition = API.FunctionDefinition;
  export type FunctionParameters = API.FunctionParameters;
}

export { toFile, fileFromPath } from './uploads';
export {
  GroqError,
  APIError,
  APIConnectionError,
  APIConnectionTimeoutError,
  APIUserAbortError,
  NotFoundError,
  ConflictError,
  RateLimitError,
  BadRequestError,
  AuthenticationError,
  InternalServerError,
  PermissionDeniedError,
  UnprocessableEntityError,
} from './error';

export default Groq;



================================================
FILE: src/resource.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import type { Groq } from './index';

export abstract class APIResource {
  protected _client: Groq;

  constructor(client: Groq) {
    this._client = client;
  }
}



================================================
FILE: src/resources.ts
================================================
export * from './resources/index';



================================================
FILE: src/uploads.ts
================================================
import { type RequestOptions } from './core';
import {
  FormData,
  File,
  type Blob,
  type FilePropertyBag,
  getMultipartRequestOptions,
  type FsReadStream,
  isFsReadStream,
} from './_shims/index';
import { MultipartBody } from './_shims/MultipartBody';
export { fileFromPath } from './_shims/index';

type BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;
export type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;

/**
 * Typically, this is a native "File" class.
 *
 * We provide the {@link toFile} utility to convert a variety of objects
 * into the File class.
 *
 * For convenience, you can also pass a fetch Response, or in Node,
 * the result of fs.createReadStream().
 */
export type Uploadable = FileLike | ResponseLike | FsReadStream;

/**
 * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.
 */
export interface BlobLike {
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */
  readonly size: number;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */
  readonly type: string;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */
  text(): Promise<string>;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */
  slice(start?: number, end?: number): BlobLike;
  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method
}

/**
 * Intended to match web.File, node.File, node-fetch.File, etc.
 */
export interface FileLike extends BlobLike {
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */
  readonly lastModified: number;
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */
  readonly name: string;
}

/**
 * Intended to match web.Response, node.Response, node-fetch.Response, etc.
 */
export interface ResponseLike {
  url: string;
  blob(): Promise<BlobLike>;
}

export const isResponseLike = (value: any): value is ResponseLike =>
  value != null &&
  typeof value === 'object' &&
  typeof value.url === 'string' &&
  typeof value.blob === 'function';

export const isFileLike = (value: any): value is FileLike =>
  value != null &&
  typeof value === 'object' &&
  typeof value.name === 'string' &&
  typeof value.lastModified === 'number' &&
  isBlobLike(value);

/**
 * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check
 * adds the arrayBuffer() method type because it is available and used at runtime
 */
export const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>
  value != null &&
  typeof value === 'object' &&
  typeof value.size === 'number' &&
  typeof value.type === 'string' &&
  typeof value.text === 'function' &&
  typeof value.slice === 'function' &&
  typeof value.arrayBuffer === 'function';

export const isUploadable = (value: any): value is Uploadable => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};

export type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;

/**
 * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats
 * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s
 * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible
 * @param {Object=} options additional properties
 * @param {string=} options.type the MIME type of the content
 * @param {number=} options.lastModified the last modified timestamp
 * @returns a {@link File} with the given properties
 */
export async function toFile(
  value: ToFileInput | PromiseLike<ToFileInput>,
  name?: string | null | undefined,
  options?: FilePropertyBag | undefined,
): Promise<FileLike> {
  // If it's a promise, resolve it.
  value = await value;

  // If we've been given a `File` we don't need to do anything
  if (isFileLike(value)) {
    return value;
  }

  if (isResponseLike(value)) {
    const blob = await value.blob();
    name ||= new URL(value.url).pathname.split(/[\\/]/).pop() ?? 'unknown_file';

    // we need to convert the `Blob` into an array buffer because the `Blob` class
    // that `node-fetch` defines is incompatible with the web standard which results
    // in `new File` interpreting it as a string instead of binary data.
    const data = isBlobLike(blob) ? [(await blob.arrayBuffer()) as any] : [blob];

    return new File(data, name, options);
  }

  const bits = await getBytes(value);

  name ||= getName(value) ?? 'unknown_file';

  if (!options?.type) {
    const type = (bits[0] as any)?.type;
    if (typeof type === 'string') {
      options = { ...options, type };
    }
  }

  return new File(bits, name, options);
}

async function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {
  let parts: Array<BlobPart> = [];
  if (
    typeof value === 'string' ||
    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
    value instanceof ArrayBuffer
  ) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (
    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.
  ) {
    for await (const chunk of value) {
      parts.push(chunk as BlobPart); // TODO, consider validating?
    }
  } else {
    throw new Error(
      `Unexpected data type: ${typeof value}; constructor: ${value?.constructor
        ?.name}; props: ${propsForError(value)}`,
    );
  }

  return parts;
}

function propsForError(value: any): string {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(', ')}]`;
}

function getName(value: any): string | undefined {
  return (
    getStringFromMaybeBuffer(value.name) ||
    getStringFromMaybeBuffer(value.filename) ||
    // For fs.ReadStream
    getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop()
  );
}

const getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {
  if (typeof x === 'string') return x;
  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);
  return undefined;
};

const isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>
  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';

export const isMultipartBody = (body: any): body is MultipartBody =>
  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';

/**
 * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.
 * Otherwise returns the request as is.
 */
export const maybeMultipartFormRequestOptions = async <T = Record<string, unknown>>(
  opts: RequestOptions<T>,
): Promise<RequestOptions<T | MultipartBody>> => {
  if (!hasUploadableValue(opts.body)) return opts;

  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};

export const multipartFormRequestOptions = async <T = Record<string, unknown>>(
  opts: RequestOptions<T>,
): Promise<RequestOptions<T | MultipartBody>> => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};

export const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};

const hasUploadableValue = (value: unknown): boolean => {
  if (isUploadable(value)) return true;
  if (Array.isArray(value)) return value.some(hasUploadableValue);
  if (value && typeof value === 'object') {
    for (const k in value) {
      if (hasUploadableValue((value as any)[k])) return true;
    }
  }
  return false;
};

const addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {
  if (value === undefined) return;
  if (value == null) {
    throw new TypeError(
      `Received null for "${key}"; to pass null in FormData, you must use the string 'null'`,
    );
  }

  // TODO: make nested formats configurable
  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file as File);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));
  } else if (typeof value === 'object') {
    await Promise.all(
      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),
    );
  } else {
    throw new TypeError(
      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,
    );
  }
};



================================================
FILE: src/version.ts
================================================
export const VERSION = '0.31.0'; // x-release-please-version



================================================
FILE: src/_shims/README.md
================================================
# 👋 Wondering what everything in here does?

`groq-sdk` supports a wide variety of runtime environments like Node.js, Deno, Bun, browsers, and various
edge runtimes, as well as both CommonJS (CJS) and EcmaScript Modules (ESM).

To do this, `groq-sdk` provides shims for either using `node-fetch` when in Node (because `fetch` is still experimental there) or the global `fetch` API built into the environment when not in Node.

It uses [conditional exports](https://nodejs.org/api/packages.html#conditional-exports) to
automatically select the correct shims for each environment. However, conditional exports are a fairly new
feature and not supported everywhere. For instance, the TypeScript `"moduleResolution": "node"`

setting doesn't consult the `exports` map, compared to `"moduleResolution": "nodeNext"`, which does.
Unfortunately that's still the default setting, and it can result in errors like
getting the wrong raw `Response` type from `.asResponse()`, for example.

The user can work around these issues by manually importing one of:

- `import 'groq-sdk/shims/node'`
- `import 'groq-sdk/shims/web'`

All of the code here in `_shims` handles selecting the automatic default shims or manual overrides.

### How it works - Runtime

Runtime shims get installed by calling `setShims` exported by `groq-sdk/_shims/registry`.

Manually importing `groq-sdk/shims/node` or `groq-sdk/shims/web`, calls `setShims` with the respective runtime shims.

All client code imports shims from `groq-sdk/_shims/index`, which:

- checks if shims have been set manually
- if not, calls `setShims` with the shims from `groq-sdk/_shims/auto/runtime`
- re-exports the installed shims from `groq-sdk/_shims/registry`.

`groq-sdk/_shims/auto/runtime` exports web runtime shims.
If the `node` export condition is set, the export map replaces it with `groq-sdk/_shims/auto/runtime-node`.

### How it works - Type time

All client code imports shim types from `groq-sdk/_shims/index`, which selects the manual types from `groq-sdk/_shims/manual-types` if they have been declared, otherwise it exports the auto types from `groq-sdk/_shims/auto/types`.

`groq-sdk/_shims/manual-types` exports an empty namespace.
Manually importing `groq-sdk/shims/node` or `groq-sdk/shims/web` merges declarations into this empty namespace, so they get picked up by `groq-sdk/_shims/index`.

`groq-sdk/_shims/auto/types` exports web type definitions.
If the `node` export condition is set, the export map replaces it with `groq-sdk/_shims/auto/types-node`, though TS only picks this up if `"moduleResolution": "nodenext"` or `"moduleResolution": "bundler"`.



================================================
FILE: src/_shims/bun-runtime.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
import { type Shims } from './registry';
import { getRuntime as getWebRuntime } from './web-runtime';
import { ReadStream as FsReadStream } from 'node:fs';

export function getRuntime(): Shims {
  const runtime = getWebRuntime();
  function isFsReadStream(value: any): value is FsReadStream {
    return value instanceof FsReadStream;
  }
  return { ...runtime, isFsReadStream };
}



================================================
FILE: src/_shims/index-deno.ts
================================================
import { MultipartBody } from './MultipartBody';
import { type RequestOptions } from '../core';

export const kind: string = 'web';

export type Agent = any;

const _fetch = fetch;
type _fetch = typeof fetch;
export { _fetch as fetch };

const _Request = Request;
type _Request = Request;
export { _Request as Request };

type _RequestInfo = RequestInfo;
export { type _RequestInfo as RequestInfo };

type _RequestInit = RequestInit;
export { type _RequestInit as RequestInit };

const _Response = Response;
type _Response = Response;
export { _Response as Response };

type _ResponseInit = ResponseInit;
export { type _ResponseInit as ResponseInit };

type _ResponseType = ResponseType;
export { type _ResponseType as ResponseType };

type _BodyInit = BodyInit;
export { type _BodyInit as BodyInit };

const _Headers = Headers;
type _Headers = Headers;
export { _Headers as Headers };

type _HeadersInit = HeadersInit;
export { type _HeadersInit as HeadersInit };

type EndingType = 'native' | 'transparent';

export interface BlobPropertyBag {
  endings?: EndingType;
  type?: string;
}

export interface FilePropertyBag extends BlobPropertyBag {
  lastModified?: number;
}

export type FileFromPathOptions = Omit<FilePropertyBag, 'lastModified'>;

const _FormData = FormData;
type _FormData = FormData;
export { _FormData as FormData };

const _File = File;
type _File = File;
export { _File as File };

const _Blob = Blob;
type _Blob = Blob;
export { _Blob as Blob };

export async function getMultipartRequestOptions<T = Record<string, unknown>>(
  form: FormData,
  opts: RequestOptions<T>,
): Promise<RequestOptions<T>> {
  return {
    ...opts,
    body: new MultipartBody(form) as any,
  };
}

export function getDefaultAgent(url: string) {
  return undefined;
}
export function fileFromPath() {
  throw new Error(
    'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads',
  );
}

export const isFsReadStream = (value: any) => false;

export declare class Readable {
  readable: boolean;
  readonly readableEnded: boolean;
  readonly readableFlowing: boolean | null;
  readonly readableHighWaterMark: number;
  readonly readableLength: number;
  readonly readableObjectMode: boolean;
  destroyed: boolean;
  read(size?: number): any;
  pause(): this;
  resume(): this;
  isPaused(): boolean;
  destroy(error?: Error): this;
  [Symbol.asyncIterator](): AsyncIterableIterator<any>;
}

export declare class FsReadStream extends Readable {
  path: {}; // node type is string | Buffer
}

const _ReadableStream = ReadableStream;
type _ReadableStream = ReadableStream;
export { _ReadableStream as ReadableStream };

export const init = () => {};



================================================
FILE: src/_shims/index.d.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
import { manual } from './manual-types';
import * as auto from 'groq-sdk/_shims/auto/types';
import { type RequestOptions } from '../core';

type SelectType<Manual, Auto> = unknown extends Manual ? Auto : Manual;

export const kind: string;

// @ts-ignore
export type Agent = SelectType<manual.Agent, auto.Agent>;

// @ts-ignore
export const fetch: SelectType<typeof manual.fetch, typeof auto.fetch>;

// @ts-ignore
export type Request = SelectType<manual.Request, auto.Request>;
// @ts-ignore
export type RequestInfo = SelectType<manual.RequestInfo, auto.RequestInfo>;
// @ts-ignore
export type RequestInit = SelectType<manual.RequestInit, auto.RequestInit>;

// @ts-ignore
export type Response = SelectType<manual.Response, auto.Response>;
// @ts-ignore
export type ResponseInit = SelectType<manual.ResponseInit, auto.ResponseInit>;
// @ts-ignore
export type ResponseType = SelectType<manual.ResponseType, auto.ResponseType>;
// @ts-ignore
export type BodyInit = SelectType<manual.BodyInit, auto.BodyInit>;
// @ts-ignore
export type Headers = SelectType<manual.Headers, auto.Headers>;
// @ts-ignore
export const Headers: SelectType<typeof manual.Headers, typeof auto.Headers>;
// @ts-ignore
export type HeadersInit = SelectType<manual.HeadersInit, auto.HeadersInit>;

// @ts-ignore
export type BlobPropertyBag = SelectType<manual.BlobPropertyBag, auto.BlobPropertyBag>;
// @ts-ignore
export type FilePropertyBag = SelectType<manual.FilePropertyBag, auto.FilePropertyBag>;
// @ts-ignore
export type FileFromPathOptions = SelectType<manual.FileFromPathOptions, auto.FileFromPathOptions>;
// @ts-ignore
export type FormData = SelectType<manual.FormData, auto.FormData>;
// @ts-ignore
export const FormData: SelectType<typeof manual.FormData, typeof auto.FormData>;
// @ts-ignore
export type File = SelectType<manual.File, auto.File>;
// @ts-ignore
export const File: SelectType<typeof manual.File, typeof auto.File>;
// @ts-ignore
export type Blob = SelectType<manual.Blob, auto.Blob>;
// @ts-ignore
export const Blob: SelectType<typeof manual.Blob, typeof auto.Blob>;

// @ts-ignore
export type Readable = SelectType<manual.Readable, auto.Readable>;
// @ts-ignore
export type FsReadStream = SelectType<manual.FsReadStream, auto.FsReadStream>;
// @ts-ignore
export type ReadableStream = SelectType<manual.ReadableStream, auto.ReadableStream>;
// @ts-ignore
export const ReadableStream: SelectType<typeof manual.ReadableStream, typeof auto.ReadableStream>;

export function getMultipartRequestOptions<T = Record<string, unknown>>(
  form: FormData,
  opts: RequestOptions<T>,
): Promise<RequestOptions<T>>;

export function getDefaultAgent(url: string): any;

// @ts-ignore
export type FileFromPathOptions = SelectType<manual.FileFromPathOptions, auto.FileFromPathOptions>;

export function fileFromPath(path: string, options?: FileFromPathOptions): Promise<File>;
export function fileFromPath(path: string, filename?: string, options?: FileFromPathOptions): Promise<File>;

export function isFsReadStream(value: any): value is FsReadStream;

export const init: () => void;



================================================
FILE: src/_shims/index.js
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
const shims = require('./registry');
const auto = require('groq-sdk/_shims/auto/runtime');
exports.init = () => {
  if (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });
};
for (const property of Object.keys(shims)) {
  Object.defineProperty(exports, property, {
    get() {
      return shims[property];
    },
  });
}

exports.init();



================================================
FILE: src/_shims/index.mjs
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
import * as shims from './registry.mjs';
import * as auto from 'groq-sdk/_shims/auto/runtime';
export const init = () => {
  if (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });
};
export * from './registry.mjs';

init();



================================================
FILE: src/_shims/manual-types.d.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
/**
 * Types will get added to this namespace when you import one of the following:
 *
 *   import 'groq-sdk/shims/node'
 *   import 'groq-sdk/shims/web'
 *
 * Importing more than one will cause type and runtime errors.
 */
export namespace manual {}



================================================
FILE: src/_shims/manual-types.js
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/_shims/manual-types.mjs
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/_shims/MultipartBody.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export class MultipartBody {
  constructor(public body: any) {}
  get [Symbol.toStringTag](): string {
    return 'MultipartBody';
  }
}



================================================
FILE: src/_shims/node-runtime.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
import * as nf from 'node-fetch';
import * as fd from 'formdata-node';
import { type File, type FilePropertyBag } from 'formdata-node';
import KeepAliveAgent from 'agentkeepalive';
import { AbortController as AbortControllerPolyfill } from 'abort-controller';
import { ReadStream as FsReadStream } from 'node:fs';
import { type Agent } from 'node:http';
import { FormDataEncoder } from 'form-data-encoder';
import { Readable } from 'node:stream';
import { type RequestOptions } from '../core';
import { MultipartBody } from './MultipartBody';
import { type Shims } from './registry';
import { ReadableStream } from 'node:stream/web';

type FileFromPathOptions = Omit<FilePropertyBag, 'lastModified'>;

let fileFromPathWarned = false;

/**
 * @deprecated use fs.createReadStream('./my/file.txt') instead
 */
async function fileFromPath(path: string): Promise<File>;
async function fileFromPath(path: string, filename?: string): Promise<File>;
async function fileFromPath(path: string, options?: FileFromPathOptions): Promise<File>;
async function fileFromPath(path: string, filename?: string, options?: FileFromPathOptions): Promise<File>;
async function fileFromPath(path: string, ...args: any[]): Promise<File> {
  // this import fails in environments that don't handle export maps correctly, like old versions of Jest
  const { fileFromPath: _fileFromPath } = await import('formdata-node/file-from-path');

  if (!fileFromPathWarned) {
    console.warn(`fileFromPath is deprecated; use fs.createReadStream(${JSON.stringify(path)}) instead`);
    fileFromPathWarned = true;
  }
  // @ts-ignore
  return await _fileFromPath(path, ...args);
}

const defaultHttpAgent: Agent = new KeepAliveAgent({ keepAlive: true, timeout: 5 * 60 * 1000 });
const defaultHttpsAgent: Agent = new KeepAliveAgent.HttpsAgent({ keepAlive: true, timeout: 5 * 60 * 1000 });

async function getMultipartRequestOptions<T = Record<string, unknown>>(
  form: fd.FormData,
  opts: RequestOptions<T>,
): Promise<RequestOptions<T>> {
  const encoder = new FormDataEncoder(form);
  const readable = Readable.from(encoder);
  const body = new MultipartBody(readable);
  const headers = {
    ...opts.headers,
    ...encoder.headers,
    'Content-Length': encoder.contentLength,
  };

  return { ...opts, body: body as any, headers };
}

export function getRuntime(): Shims {
  // Polyfill global object if needed.
  if (typeof AbortController === 'undefined') {
    // @ts-expect-error (the types are subtly different, but compatible in practice)
    globalThis.AbortController = AbortControllerPolyfill;
  }
  return {
    kind: 'node',
    fetch: nf.default,
    Request: nf.Request,
    Response: nf.Response,
    Headers: nf.Headers,
    FormData: fd.FormData,
    Blob: fd.Blob,
    File: fd.File,
    ReadableStream,
    getMultipartRequestOptions,
    getDefaultAgent: (url: string): Agent => (url.startsWith('https') ? defaultHttpsAgent : defaultHttpAgent),
    fileFromPath,
    isFsReadStream: (value: any): value is FsReadStream => value instanceof FsReadStream,
  };
}



================================================
FILE: src/_shims/node-types.d.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
import * as nf from 'node-fetch';
import * as fd from 'formdata-node';

export { type Agent } from 'node:http';
export { type Readable } from 'node:stream';
export { type ReadStream as FsReadStream } from 'node:fs';
export { ReadableStream } from 'node:stream/web';

export const fetch: typeof nf.default;

export type Request = nf.Request;
export type RequestInfo = nf.RequestInfo;
export type RequestInit = nf.RequestInit;

export type Response = nf.Response;
export type ResponseInit = nf.ResponseInit;
export type ResponseType = nf.ResponseType;
export type BodyInit = nf.BodyInit;
export type Headers = nf.Headers;
export type HeadersInit = nf.HeadersInit;

type EndingType = 'native' | 'transparent';
export interface BlobPropertyBag {
  endings?: EndingType;
  type?: string;
}

export interface FilePropertyBag extends BlobPropertyBag {
  lastModified?: number;
}

export type FileFromPathOptions = Omit<FilePropertyBag, 'lastModified'>;

export type FormData = fd.FormData;
export const FormData: typeof fd.FormData;
export type File = fd.File;
export const File: typeof fd.File;
export type Blob = fd.Blob;
export const Blob: typeof fd.Blob;



================================================
FILE: src/_shims/node-types.js
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/_shims/node-types.mjs
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/_shims/registry.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
import { type RequestOptions } from '../core';

export interface Shims {
  kind: string;
  fetch: any;
  Request: any;
  Response: any;
  Headers: any;
  FormData: any;
  Blob: any;
  File: any;
  ReadableStream: any;
  getMultipartRequestOptions: <T = Record<string, unknown>>(
    form: Shims['FormData'],
    opts: RequestOptions<T>,
  ) => Promise<RequestOptions<T>>;
  getDefaultAgent: (url: string) => any;
  fileFromPath:
    | ((path: string, filename?: string, options?: {}) => Promise<Shims['File']>)
    | ((path: string, options?: {}) => Promise<Shims['File']>);
  isFsReadStream: (value: any) => boolean;
}

export let auto = false;
export let kind: Shims['kind'] | undefined = undefined;
export let fetch: Shims['fetch'] | undefined = undefined;
export let Request: Shims['Request'] | undefined = undefined;
export let Response: Shims['Response'] | undefined = undefined;
export let Headers: Shims['Headers'] | undefined = undefined;
export let FormData: Shims['FormData'] | undefined = undefined;
export let Blob: Shims['Blob'] | undefined = undefined;
export let File: Shims['File'] | undefined = undefined;
export let ReadableStream: Shims['ReadableStream'] | undefined = undefined;
export let getMultipartRequestOptions: Shims['getMultipartRequestOptions'] | undefined = undefined;
export let getDefaultAgent: Shims['getDefaultAgent'] | undefined = undefined;
export let fileFromPath: Shims['fileFromPath'] | undefined = undefined;
export let isFsReadStream: Shims['isFsReadStream'] | undefined = undefined;

export function setShims(shims: Shims, options: { auto: boolean } = { auto: false }) {
  if (auto) {
    throw new Error(
      `you must \`import 'groq-sdk/shims/${shims.kind}'\` before importing anything else from groq-sdk`,
    );
  }
  if (kind) {
    throw new Error(
      `can't \`import 'groq-sdk/shims/${shims.kind}'\` after \`import 'groq-sdk/shims/${kind}'\``,
    );
  }
  auto = options.auto;
  kind = shims.kind;
  fetch = shims.fetch;
  Request = shims.Request;
  Response = shims.Response;
  Headers = shims.Headers;
  FormData = shims.FormData;
  Blob = shims.Blob;
  File = shims.File;
  ReadableStream = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}



================================================
FILE: src/_shims/web-runtime.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
import { MultipartBody } from './MultipartBody';
import { type RequestOptions } from '../core';
import { type Shims } from './registry';

export function getRuntime({ manuallyImported }: { manuallyImported?: boolean } = {}): Shims {
  const recommendation =
    manuallyImported ?
      `You may need to use polyfills`
    : `Add one of these imports before your first \`import … from 'groq-sdk'\`:
- \`import 'groq-sdk/shims/node'\` (if you're running on Node)
- \`import 'groq-sdk/shims/web'\` (otherwise)
`;

  let _fetch, _Request, _Response, _Headers;
  try {
    // @ts-ignore
    _fetch = fetch;
    // @ts-ignore
    _Request = Request;
    // @ts-ignore
    _Response = Response;
    // @ts-ignore
    _Headers = Headers;
  } catch (error) {
    throw new Error(
      `this environment is missing the following Web Fetch API type: ${
        (error as any).message
      }. ${recommendation}`,
    );
  }

  return {
    kind: 'web',
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData:
      // @ts-ignore
      typeof FormData !== 'undefined' ? FormData : (
        class FormData {
          // @ts-ignore
          constructor() {
            throw new Error(
              `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`,
            );
          }
        }
      ),
    Blob:
      typeof Blob !== 'undefined' ? Blob : (
        class Blob {
          constructor() {
            throw new Error(
              `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`,
            );
          }
        }
      ),
    File:
      // @ts-ignore
      typeof File !== 'undefined' ? File : (
        class File {
          // @ts-ignore
          constructor() {
            throw new Error(
              `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`,
            );
          }
        }
      ),
    ReadableStream:
      // @ts-ignore
      typeof ReadableStream !== 'undefined' ? ReadableStream : (
        class ReadableStream {
          // @ts-ignore
          constructor() {
            throw new Error(
              `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`,
            );
          }
        }
      ),
    getMultipartRequestOptions: async <T = Record<string, unknown>>(
      // @ts-ignore
      form: FormData,
      opts: RequestOptions<T>,
    ): Promise<RequestOptions<T>> => ({
      ...opts,
      body: new MultipartBody(form) as any,
    }),
    getDefaultAgent: (url: string) => undefined,
    fileFromPath: () => {
      throw new Error(
        'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads',
      );
    },
    isFsReadStream: (value: any) => false,
  };
}



================================================
FILE: src/_shims/web-types.d.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export type Agent = any;

declare const _fetch: typeof fetch;
export { _fetch as fetch };

type _Request = Request;
export { _Request as Request };

type _RequestInfo = RequestInfo;
export { type _RequestInfo as RequestInfo };

type _RequestInit = RequestInit;
export { type _RequestInit as RequestInit };

type _Response = Response;
export { _Response as Response };

type _ResponseInit = ResponseInit;
export { type _ResponseInit as ResponseInit };

type _ResponseType = ResponseType;
export { type _ResponseType as ResponseType };

type _BodyInit = BodyInit;
export { type _BodyInit as BodyInit };

type _Headers = Headers;
export { _Headers as Headers };

type _HeadersInit = HeadersInit;
export { type _HeadersInit as HeadersInit };

type EndingType = 'native' | 'transparent';

export interface BlobPropertyBag {
  endings?: EndingType;
  type?: string;
}

export interface FilePropertyBag extends BlobPropertyBag {
  lastModified?: number;
}

export type FileFromPathOptions = Omit<FilePropertyBag, 'lastModified'>;

type _FormData = FormData;
declare const _FormData: typeof FormData;
export { _FormData as FormData };

type _File = File;
declare const _File: typeof File;
export { _File as File };

type _Blob = Blob;
declare const _Blob: typeof Blob;
export { _Blob as Blob };

export declare class Readable {
  readable: boolean;
  readonly readableEnded: boolean;
  readonly readableFlowing: boolean | null;
  readonly readableHighWaterMark: number;
  readonly readableLength: number;
  readonly readableObjectMode: boolean;
  destroyed: boolean;
  read(size?: number): any;
  pause(): this;
  resume(): this;
  isPaused(): boolean;
  destroy(error?: Error): this;
  [Symbol.asyncIterator](): AsyncIterableIterator<any>;
}

export declare class FsReadStream extends Readable {
  path: {}; // node type is string | Buffer
}

type _ReadableStream<R = any> = ReadableStream<R>;
declare const _ReadableStream: typeof ReadableStream;
export { _ReadableStream as ReadableStream };



================================================
FILE: src/_shims/web-types.js
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/_shims/web-types.mjs
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/_shims/auto/runtime-bun.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export * from '../bun-runtime';



================================================
FILE: src/_shims/auto/runtime-deno.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export * from '../web-runtime';



================================================
FILE: src/_shims/auto/runtime-node.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export * from '../node-runtime';



================================================
FILE: src/_shims/auto/runtime.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export * from '../web-runtime';



================================================
FILE: src/_shims/auto/types-deno.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export * from '../web-types';



================================================
FILE: src/_shims/auto/types-node.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export * from '../node-types';



================================================
FILE: src/_shims/auto/types.d.ts
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */
export type Agent = any;

// @ts-ignore
declare const _fetch: unknown extends typeof fetch ? never : typeof fetch;
export { _fetch as fetch };

// @ts-ignore
type _Request = unknown extends Request ? never : Request;
export { _Request as Request };

// @ts-ignore
type _RequestInfo = unknown extends RequestInfo ? never : RequestInfo;
export { type _RequestInfo as RequestInfo };

// @ts-ignore
type _RequestInit = unknown extends RequestInit ? never : RequestInit;
export { type _RequestInit as RequestInit };

// @ts-ignore
type _Response = unknown extends Response ? never : Response;
export { _Response as Response };

// @ts-ignore
type _ResponseInit = unknown extends ResponseInit ? never : ResponseInit;
export { type _ResponseInit as ResponseInit };

// @ts-ignore
type _ResponseType = unknown extends ResponseType ? never : ResponseType;
export { type _ResponseType as ResponseType };

// @ts-ignore
type _BodyInit = unknown extends BodyInit ? never : BodyInit;
export { type _BodyInit as BodyInit };

// @ts-ignore
type _Headers = unknown extends Headers ? never : Headers;
export { _Headers as Headers };

// @ts-ignore
type _HeadersInit = unknown extends HeadersInit ? never : HeadersInit;
export { type _HeadersInit as HeadersInit };

type EndingType = 'native' | 'transparent';

export interface BlobPropertyBag {
  endings?: EndingType;
  type?: string;
}

export interface FilePropertyBag extends BlobPropertyBag {
  lastModified?: number;
}

export type FileFromPathOptions = Omit<FilePropertyBag, 'lastModified'>;

// @ts-ignore
type _FormData = unknown extends FormData ? never : FormData;
// @ts-ignore
declare const _FormData: unknown extends typeof FormData ? never : typeof FormData;
export { _FormData as FormData };

// @ts-ignore
type _File = unknown extends File ? never : File;
// @ts-ignore
declare const _File: unknown extends typeof File ? never : typeof File;
export { _File as File };

// @ts-ignore
type _Blob = unknown extends Blob ? never : Blob;
// @ts-ignore
declare const _Blob: unknown extends typeof Blob ? never : typeof Blob;
export { _Blob as Blob };

export declare class Readable {
  readable: boolean;
  readonly readableEnded: boolean;
  readonly readableFlowing: boolean | null;
  readonly readableHighWaterMark: number;
  readonly readableLength: number;
  readonly readableObjectMode: boolean;
  destroyed: boolean;
  read(size?: number): any;
  pause(): this;
  resume(): this;
  isPaused(): boolean;
  destroy(error?: Error): this;
  [Symbol.asyncIterator](): AsyncIterableIterator<any>;
}

export declare class FsReadStream extends Readable {
  path: {}; // node type is string | Buffer
}

// @ts-ignore
type _ReadableStream<R = any> = unknown extends ReadableStream<R> ? never : ReadableStream<R>;
// @ts-ignore
declare const _ReadableStream: unknown extends typeof ReadableStream ? never : typeof ReadableStream;
export { _ReadableStream as ReadableStream };



================================================
FILE: src/_shims/auto/types.js
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/_shims/auto/types.mjs
================================================
/**
 * Disclaimer: modules in _shims aren't intended to be imported by SDK users.
 */



================================================
FILE: src/lib/streaming.ts
================================================
import { ReadableStream, type Response } from '../_shims/index';
import { GroqError } from '../error';

import { APIError } from '../error';

type Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;

export type ServerSentEvent = {
  event: string | null;
  data: string;
  raw: string[];
};

export class Stream<Item> implements AsyncIterable<Item> {
  controller: AbortController;

  constructor(
    private iterator: () => AsyncIterator<Item>,
    controller: AbortController,
  ) {
    this.controller = controller;
  }

  static fromSSEResponse<Item>(response: Response, controller: AbortController) {
    let consumed = false;
    const decoder = new SSEDecoder();

    async function* iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {
      if (!response.body) {
        controller.abort();
        throw new GroqError(`Attempted to iterate over a response with no body`);
      }

      const lineDecoder = new LineDecoder();

      const iter = readableStreamAsyncIterable<Bytes>(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse) yield sse;
        }
      }

      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse) yield sse;
      }
    }

    async function* iterator(): AsyncIterator<Item, any, undefined> {
      if (consumed) {
        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done) continue;

          if (sse.data.startsWith('[DONE]')) {
            done = true;
            continue;
          }

          if (sse.event === null || sse.event === 'error') {
            let data;

            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }

            if (data && data.error) {
              throw new APIError(data.error.status_code, data.error, data.error.message, undefined);
            }

            yield data;
          }
        }
        done = true;
      } catch (e) {
        // If the user calls `stream.controller.abort()`, we should exit without throwing.
        if (e instanceof Error && e.name === 'AbortError') return;
        throw e;
      } finally {
        // If the user `break`s, abort the ongoing request.
        if (!done) controller.abort();
      }
    }

    return new Stream(iterator, controller);
  }

  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {
    let consumed = false;

    async function* iterLines(): AsyncGenerator<string, void, unknown> {
      const lineDecoder = new LineDecoder();

      const iter = readableStreamAsyncIterable<Bytes>(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }

      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }

    async function* iterator(): AsyncIterator<Item, any, undefined> {
      if (consumed) {
        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done) continue;
          if (line) yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        // If the user calls `stream.controller.abort()`, we should exit without throwing.
        if (e instanceof Error && e.name === 'AbortError') return;
        throw e;
      } finally {
        // If the user `break`s, abort the ongoing request.
        if (!done) controller.abort();
      }
    }

    return new Stream(iterator, controller);
  }

  [Symbol.asyncIterator](): AsyncIterator<Item> {
    return this.iterator();
  }

  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee(): [Stream<Item>, Stream<Item>] {
    const left: Array<Promise<IteratorResult<Item>>> = [];
    const right: Array<Promise<IteratorResult<Item>>> = [];
    const iterator = this.iterator();

    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift()!;
        },
      };
    };

    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller),
    ];
  }

  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream(): ReadableStream {
    const self = this;
    let iter: AsyncIterator<Item>;
    const encoder = new TextEncoder();

    return new ReadableStream({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done) return ctrl.close();

          const bytes = encoder.encode(JSON.stringify(value) + '\n');

          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      },
    });
  }
}

class SSEDecoder {
  private data: string[];
  private event: string | null;
  private chunks: string[];

  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }

  decode(line: string) {
    if (line.endsWith('\r')) {
      line = line.substring(0, line.length - 1);
    }

    if (!line) {
      // empty line and we didn't previously encounter any messages
      if (!this.event && !this.data.length) return null;

      const sse: ServerSentEvent = {
        event: this.event,
        data: this.data.join('\n'),
        raw: this.chunks,
      };

      this.event = null;
      this.data = [];
      this.chunks = [];

      return sse;
    }

    this.chunks.push(line);

    if (line.startsWith(':')) {
      return null;
    }

    let [fieldname, _, value] = partition(line, ':');

    if (value.startsWith(' ')) {
      value = value.substring(1);
    }

    if (fieldname === 'event') {
      this.event = value;
    } else if (fieldname === 'data') {
      this.data.push(value);
    }

    return null;
  }
}

/**
 * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally
 * reading lines from text.
 *
 * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258
 */
class LineDecoder {
  // prettier-ignore
  static NEWLINE_CHARS = new Set(['\n', '\r', '\x0b', '\x0c', '\x1c', '\x1d', '\x1e', '\x85', '\u2028', '\u2029']);
  static NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;

  buffer: string[];
  trailingCR: boolean;
  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either "dom" or "node" types.

  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }

  decode(chunk: Bytes): string[] {
    let text = this.decodeText(chunk);

    if (this.trailingCR) {
      text = '\r' + text;
      this.trailingCR = false;
    }
    if (text.endsWith('\r')) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }

    if (!text) {
      return [];
    }

    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);

    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]!);
      return [];
    }

    if (this.buffer.length > 0) {
      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }

    if (!trailingNewline) {
      this.buffer = [lines.pop() || ''];
    }

    return lines;
  }

  decodeText(bytes: Bytes): string {
    if (bytes == null) return '';
    if (typeof bytes === 'string') return bytes;

    // Node:
    if (typeof Buffer !== 'undefined') {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }

      throw new GroqError(
        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`,
      );
    }

    // Browser
    if (typeof TextDecoder !== 'undefined') {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ??= new TextDecoder('utf8');
        return this.textDecoder.decode(bytes);
      }

      throw new GroqError(
        `Unexpected: received non-Uint8Array/ArrayBuffer (${
          (bytes as any).constructor.name
        }) in a web platform. Please report this error.`,
      );
    }

    throw new GroqError(
      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,
    );
  }

  flush(): string[] {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }

    const lines = [this.buffer.join('')];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
}

function partition(str: string, delimiter: string): [string, string, string] {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }

  return [str, '', ''];
}

/**
 * Most browsers don't yet have async iterable support for ReadableStream,
 * and Node has a very different way of reading bytes from its "ReadableStream".
 *
 * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490
 */
export function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {
  if (stream[Symbol.asyncIterator]) return stream;

  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed
        return result;
      } catch (e) {
        reader.releaseLock(); // release lock when stream becomes errored
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: undefined };
    },
    [Symbol.asyncIterator]() {
      return this;
    },
  };
}



================================================
FILE: src/lib/.keep
================================================
File generated from our OpenAPI spec by Stainless.

This directory can be used to store custom files to expand the SDK.
It is ignored by Stainless code generation and its content (other than this keep file) won't be touched.



================================================
FILE: src/resources/audio.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

export * from './audio/index';



================================================
FILE: src/resources/batches.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../resource';
import * as Core from '../core';

export class Batches extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests.
   * [Learn more](/docs/batch).
   */
  create(body: BatchCreateParams, options?: Core.RequestOptions): Core.APIPromise<BatchCreateResponse> {
    return this._client.post('/openai/v1/batches', { body, ...options });
  }

  /**
   * Retrieves a batch.
   */
  retrieve(batchId: string, options?: Core.RequestOptions): Core.APIPromise<BatchRetrieveResponse> {
    return this._client.get(`/openai/v1/batches/${batchId}`, options);
  }

  /**
   * List your organization's batches.
   */
  list(options?: Core.RequestOptions): Core.APIPromise<BatchListResponse> {
    return this._client.get('/openai/v1/batches', options);
  }

  /**
   * Cancels a batch.
   */
  cancel(batchId: string, options?: Core.RequestOptions): Core.APIPromise<BatchCancelResponse> {
    return this._client.post(`/openai/v1/batches/${batchId}/cancel`, options);
  }
}

export interface BatchCreateResponse {
  id: string;

  /**
   * The time frame within which the batch should be processed.
   */
  completion_window: string;

  /**
   * The Unix timestamp (in seconds) for when the batch was created.
   */
  created_at: number;

  /**
   * The API endpoint used by the batch.
   */
  endpoint: string;

  /**
   * The ID of the input file for the batch.
   */
  input_file_id: string;

  /**
   * The object type, which is always `batch`.
   */
  object: 'batch';

  /**
   * The current status of the batch.
   */
  status:
    | 'validating'
    | 'failed'
    | 'in_progress'
    | 'finalizing'
    | 'completed'
    | 'expired'
    | 'cancelling'
    | 'cancelled';

  /**
   * The Unix timestamp (in seconds) for when the batch was cancelled.
   */
  cancelled_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started cancelling.
   */
  cancelling_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch was completed.
   */
  completed_at?: number;

  /**
   * The ID of the file containing the outputs of requests with errors.
   */
  error_file_id?: string;

  errors?: BatchCreateResponse.Errors;

  /**
   * The Unix timestamp (in seconds) for when the batch expired.
   */
  expired_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch will expire.
   */
  expires_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch failed.
   */
  failed_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started finalizing.
   */
  finalizing_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started processing.
   */
  in_progress_at?: number;

  /**
   * Set of key-value pairs that can be attached to an object. This can be useful for
   * storing additional information about the object in a structured format.
   */
  metadata?: unknown | null;

  /**
   * The ID of the file containing the outputs of successfully executed requests.
   */
  output_file_id?: string;

  /**
   * The request counts for different statuses within the batch.
   */
  request_counts?: BatchCreateResponse.RequestCounts;
}

export namespace BatchCreateResponse {
  export interface Errors {
    data?: Array<Errors.Data>;

    /**
     * The object type, which is always `list`.
     */
    object?: string;
  }

  export namespace Errors {
    export interface Data {
      /**
       * An error code identifying the error type.
       */
      code?: string;

      /**
       * The line number of the input file where the error occurred, if applicable.
       */
      line?: number | null;

      /**
       * A human-readable message providing more details about the error.
       */
      message?: string;

      /**
       * The name of the parameter that caused the error, if applicable.
       */
      param?: string | null;
    }
  }

  /**
   * The request counts for different statuses within the batch.
   */
  export interface RequestCounts {
    /**
     * Number of requests that have been completed successfully.
     */
    completed: number;

    /**
     * Number of requests that have failed.
     */
    failed: number;

    /**
     * Total number of requests in the batch.
     */
    total: number;
  }
}

export interface BatchRetrieveResponse {
  id: string;

  /**
   * The time frame within which the batch should be processed.
   */
  completion_window: string;

  /**
   * The Unix timestamp (in seconds) for when the batch was created.
   */
  created_at: number;

  /**
   * The API endpoint used by the batch.
   */
  endpoint: string;

  /**
   * The ID of the input file for the batch.
   */
  input_file_id: string;

  /**
   * The object type, which is always `batch`.
   */
  object: 'batch';

  /**
   * The current status of the batch.
   */
  status:
    | 'validating'
    | 'failed'
    | 'in_progress'
    | 'finalizing'
    | 'completed'
    | 'expired'
    | 'cancelling'
    | 'cancelled';

  /**
   * The Unix timestamp (in seconds) for when the batch was cancelled.
   */
  cancelled_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started cancelling.
   */
  cancelling_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch was completed.
   */
  completed_at?: number;

  /**
   * The ID of the file containing the outputs of requests with errors.
   */
  error_file_id?: string;

  errors?: BatchRetrieveResponse.Errors;

  /**
   * The Unix timestamp (in seconds) for when the batch expired.
   */
  expired_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch will expire.
   */
  expires_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch failed.
   */
  failed_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started finalizing.
   */
  finalizing_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started processing.
   */
  in_progress_at?: number;

  /**
   * Set of key-value pairs that can be attached to an object. This can be useful for
   * storing additional information about the object in a structured format.
   */
  metadata?: unknown | null;

  /**
   * The ID of the file containing the outputs of successfully executed requests.
   */
  output_file_id?: string;

  /**
   * The request counts for different statuses within the batch.
   */
  request_counts?: BatchRetrieveResponse.RequestCounts;
}

export namespace BatchRetrieveResponse {
  export interface Errors {
    data?: Array<Errors.Data>;

    /**
     * The object type, which is always `list`.
     */
    object?: string;
  }

  export namespace Errors {
    export interface Data {
      /**
       * An error code identifying the error type.
       */
      code?: string;

      /**
       * The line number of the input file where the error occurred, if applicable.
       */
      line?: number | null;

      /**
       * A human-readable message providing more details about the error.
       */
      message?: string;

      /**
       * The name of the parameter that caused the error, if applicable.
       */
      param?: string | null;
    }
  }

  /**
   * The request counts for different statuses within the batch.
   */
  export interface RequestCounts {
    /**
     * Number of requests that have been completed successfully.
     */
    completed: number;

    /**
     * Number of requests that have failed.
     */
    failed: number;

    /**
     * Total number of requests in the batch.
     */
    total: number;
  }
}

export interface BatchListResponse {
  data: Array<BatchListResponse.Data>;

  object: 'list';
}

export namespace BatchListResponse {
  export interface Data {
    id: string;

    /**
     * The time frame within which the batch should be processed.
     */
    completion_window: string;

    /**
     * The Unix timestamp (in seconds) for when the batch was created.
     */
    created_at: number;

    /**
     * The API endpoint used by the batch.
     */
    endpoint: string;

    /**
     * The ID of the input file for the batch.
     */
    input_file_id: string;

    /**
     * The object type, which is always `batch`.
     */
    object: 'batch';

    /**
     * The current status of the batch.
     */
    status:
      | 'validating'
      | 'failed'
      | 'in_progress'
      | 'finalizing'
      | 'completed'
      | 'expired'
      | 'cancelling'
      | 'cancelled';

    /**
     * The Unix timestamp (in seconds) for when the batch was cancelled.
     */
    cancelled_at?: number;

    /**
     * The Unix timestamp (in seconds) for when the batch started cancelling.
     */
    cancelling_at?: number;

    /**
     * The Unix timestamp (in seconds) for when the batch was completed.
     */
    completed_at?: number;

    /**
     * The ID of the file containing the outputs of requests with errors.
     */
    error_file_id?: string;

    errors?: Data.Errors;

    /**
     * The Unix timestamp (in seconds) for when the batch expired.
     */
    expired_at?: number;

    /**
     * The Unix timestamp (in seconds) for when the batch will expire.
     */
    expires_at?: number;

    /**
     * The Unix timestamp (in seconds) for when the batch failed.
     */
    failed_at?: number;

    /**
     * The Unix timestamp (in seconds) for when the batch started finalizing.
     */
    finalizing_at?: number;

    /**
     * The Unix timestamp (in seconds) for when the batch started processing.
     */
    in_progress_at?: number;

    /**
     * Set of key-value pairs that can be attached to an object. This can be useful for
     * storing additional information about the object in a structured format.
     */
    metadata?: unknown | null;

    /**
     * The ID of the file containing the outputs of successfully executed requests.
     */
    output_file_id?: string;

    /**
     * The request counts for different statuses within the batch.
     */
    request_counts?: Data.RequestCounts;
  }

  export namespace Data {
    export interface Errors {
      data?: Array<Errors.Data>;

      /**
       * The object type, which is always `list`.
       */
      object?: string;
    }

    export namespace Errors {
      export interface Data {
        /**
         * An error code identifying the error type.
         */
        code?: string;

        /**
         * The line number of the input file where the error occurred, if applicable.
         */
        line?: number | null;

        /**
         * A human-readable message providing more details about the error.
         */
        message?: string;

        /**
         * The name of the parameter that caused the error, if applicable.
         */
        param?: string | null;
      }
    }

    /**
     * The request counts for different statuses within the batch.
     */
    export interface RequestCounts {
      /**
       * Number of requests that have been completed successfully.
       */
      completed: number;

      /**
       * Number of requests that have failed.
       */
      failed: number;

      /**
       * Total number of requests in the batch.
       */
      total: number;
    }
  }
}

export interface BatchCancelResponse {
  id: string;

  /**
   * The time frame within which the batch should be processed.
   */
  completion_window: string;

  /**
   * The Unix timestamp (in seconds) for when the batch was created.
   */
  created_at: number;

  /**
   * The API endpoint used by the batch.
   */
  endpoint: string;

  /**
   * The ID of the input file for the batch.
   */
  input_file_id: string;

  /**
   * The object type, which is always `batch`.
   */
  object: 'batch';

  /**
   * The current status of the batch.
   */
  status:
    | 'validating'
    | 'failed'
    | 'in_progress'
    | 'finalizing'
    | 'completed'
    | 'expired'
    | 'cancelling'
    | 'cancelled';

  /**
   * The Unix timestamp (in seconds) for when the batch was cancelled.
   */
  cancelled_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started cancelling.
   */
  cancelling_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch was completed.
   */
  completed_at?: number;

  /**
   * The ID of the file containing the outputs of requests with errors.
   */
  error_file_id?: string;

  errors?: BatchCancelResponse.Errors;

  /**
   * The Unix timestamp (in seconds) for when the batch expired.
   */
  expired_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch will expire.
   */
  expires_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch failed.
   */
  failed_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started finalizing.
   */
  finalizing_at?: number;

  /**
   * The Unix timestamp (in seconds) for when the batch started processing.
   */
  in_progress_at?: number;

  /**
   * Set of key-value pairs that can be attached to an object. This can be useful for
   * storing additional information about the object in a structured format.
   */
  metadata?: unknown | null;

  /**
   * The ID of the file containing the outputs of successfully executed requests.
   */
  output_file_id?: string;

  /**
   * The request counts for different statuses within the batch.
   */
  request_counts?: BatchCancelResponse.RequestCounts;
}

export namespace BatchCancelResponse {
  export interface Errors {
    data?: Array<Errors.Data>;

    /**
     * The object type, which is always `list`.
     */
    object?: string;
  }

  export namespace Errors {
    export interface Data {
      /**
       * An error code identifying the error type.
       */
      code?: string;

      /**
       * The line number of the input file where the error occurred, if applicable.
       */
      line?: number | null;

      /**
       * A human-readable message providing more details about the error.
       */
      message?: string;

      /**
       * The name of the parameter that caused the error, if applicable.
       */
      param?: string | null;
    }
  }

  /**
   * The request counts for different statuses within the batch.
   */
  export interface RequestCounts {
    /**
     * Number of requests that have been completed successfully.
     */
    completed: number;

    /**
     * Number of requests that have failed.
     */
    failed: number;

    /**
     * Total number of requests in the batch.
     */
    total: number;
  }
}

export interface BatchCreateParams {
  /**
   * The time frame within which the batch should be processed. Durations from `24h`
   * to `7d` are supported.
   */
  completion_window: string;

  /**
   * The endpoint to be used for all requests in the batch. Currently
   * `/v1/chat/completions` is supported.
   */
  endpoint: '/v1/chat/completions';

  /**
   * The ID of an uploaded file that contains requests for the new batch.
   *
   * See [upload file](/docs/api-reference#files-upload) for how to upload a file.
   *
   * Your input file must be formatted as a [JSONL file](/docs/batch), and must be
   * uploaded with the purpose `batch`. The file can be up to 100 MB in size.
   */
  input_file_id: string;

  /**
   * Optional custom metadata for the batch.
   */
  metadata?: { [key: string]: string } | null;
}

export declare namespace Batches {
  export {
    type BatchCreateResponse as BatchCreateResponse,
    type BatchRetrieveResponse as BatchRetrieveResponse,
    type BatchListResponse as BatchListResponse,
    type BatchCancelResponse as BatchCancelResponse,
    type BatchCreateParams as BatchCreateParams,
  };
}



================================================
FILE: src/resources/chat.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

export * from './chat/index';



================================================
FILE: src/resources/completions.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../resource';

export class Completions extends APIResource {}

/**
 * Usage statistics for the completion request.
 */
export interface CompletionUsage {
  /**
   * Number of tokens in the generated completion.
   */
  completion_tokens: number;

  /**
   * Number of tokens in the prompt.
   */
  prompt_tokens: number;

  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  total_tokens: number;

  /**
   * Time spent generating tokens
   */
  completion_time?: number;

  /**
   * Time spent processing input tokens
   */
  prompt_time?: number;

  /**
   * Time the requests was spent queued
   */
  queue_time?: number;

  /**
   * completion time and prompt time combined
   */
  total_time?: number;
}

export declare namespace Completions {
  export { type CompletionUsage as CompletionUsage };
}



================================================
FILE: src/resources/embeddings.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../resource';
import * as Core from '../core';

export class Embeddings extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'nomic-embed-text-v1_5',
   *   });
   * ```
   */
  create(
    body: EmbeddingCreateParams,
    options?: Core.RequestOptions,
  ): Core.APIPromise<CreateEmbeddingResponse> {
    return this._client.post('/openai/v1/embeddings', { body, ...options });
  }
}

export interface CreateEmbeddingResponse {
  /**
   * The list of embeddings generated by the model.
   */
  data: Array<Embedding>;

  /**
   * The name of the model used to generate the embedding.
   */
  model: string;

  /**
   * The object type, which is always "list".
   */
  object: 'list';

  /**
   * The usage information for the request.
   */
  usage: CreateEmbeddingResponse.Usage;
}

export namespace CreateEmbeddingResponse {
  /**
   * The usage information for the request.
   */
  export interface Usage {
    /**
     * The number of tokens used by the prompt.
     */
    prompt_tokens: number;

    /**
     * The total number of tokens used by the request.
     */
    total_tokens: number;
  }
}

/**
 * Represents an embedding vector returned by embedding endpoint.
 */
export interface Embedding {
  /**
   * The embedding vector, which is a list of floats. The length of vector depends on
   * the model as listed in the [embedding guide](/docs/guides/embeddings).
   */
  embedding: Array<number> | string;

  /**
   * The index of the embedding in the list of embeddings.
   */
  index: number;

  /**
   * The object type, which is always "embedding".
   */
  object: 'embedding';
}

export interface EmbeddingCreateParams {
  /**
   * Input text to embed, encoded as a string or array of tokens. To embed multiple
   * inputs in a single request, pass an array of strings or array of token arrays.
   * The input must not exceed the max input tokens for the model, cannot be an empty
   * string, and any array must be 2048 dimensions or less.
   */
  input: string | Array<string>;

  /**
   * ID of the model to use.
   */
  model: (string & {}) | 'nomic-embed-text-v1_5';

  /**
   * The format to return the embeddings in. Can only be `float` or `base64`.
   */
  encoding_format?: 'float' | 'base64';

  /**
   * A unique identifier representing your end-user, which can help us monitor and
   * detect abuse.
   */
  user?: string | null;
}

export declare namespace Embeddings {
  export {
    type CreateEmbeddingResponse as CreateEmbeddingResponse,
    type Embedding as Embedding,
    type EmbeddingCreateParams as EmbeddingCreateParams,
  };
}



================================================
FILE: src/resources/files.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../resource';
import * as Core from '../core';
import { type Response } from '../_shims/index';

export class Files extends APIResource {
  /**
   * Upload a file that can be used across various endpoints.
   *
   * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also
   * has a specific required [format](/docs/batch).
   *
   * Please contact us if you need to increase these storage limits.
   */
  create(body: FileCreateParams, options?: Core.RequestOptions): Core.APIPromise<FileCreateResponse> {
    return this._client.post('/openai/v1/files', Core.multipartFormRequestOptions({ body, ...options }));
  }

  /**
   * Returns a list of files.
   */
  list(options?: Core.RequestOptions): Core.APIPromise<FileListResponse> {
    return this._client.get('/openai/v1/files', options);
  }

  /**
   * Delete a file.
   */
  delete(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileDeleteResponse> {
    return this._client.delete(`/openai/v1/files/${fileId}`, options);
  }

  /**
   * Returns the contents of the specified file.
   */
  content(fileId: string, options?: Core.RequestOptions): Core.APIPromise<Response> {
    return this._client.get(`/openai/v1/files/${fileId}/content`, {
      ...options,
      headers: { Accept: 'application/octet-stream', ...options?.headers },
      __binaryResponse: true,
    });
  }

  /**
   * Returns information about a file.
   */
  info(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileInfoResponse> {
    return this._client.get(`/openai/v1/files/${fileId}`, options);
  }
}

/**
 * The `File` object represents a document that has been uploaded.
 */
export interface FileCreateResponse {
  /**
   * The file identifier, which can be referenced in the API endpoints.
   */
  id?: string;

  /**
   * The size of the file, in bytes.
   */
  bytes?: number;

  /**
   * The Unix timestamp (in seconds) for when the file was created.
   */
  created_at?: number;

  /**
   * The name of the file.
   */
  filename?: string;

  /**
   * The object type, which is always `file`.
   */
  object?: 'file';

  /**
   * The intended purpose of the file. Supported values are `batch`, and
   * `batch_output`.
   */
  purpose?: 'batch' | 'batch_output';
}

export interface FileListResponse {
  data: Array<FileListResponse.Data>;

  object: 'list';
}

export namespace FileListResponse {
  /**
   * The `File` object represents a document that has been uploaded.
   */
  export interface Data {
    /**
     * The file identifier, which can be referenced in the API endpoints.
     */
    id?: string;

    /**
     * The size of the file, in bytes.
     */
    bytes?: number;

    /**
     * The Unix timestamp (in seconds) for when the file was created.
     */
    created_at?: number;

    /**
     * The name of the file.
     */
    filename?: string;

    /**
     * The object type, which is always `file`.
     */
    object?: 'file';

    /**
     * The intended purpose of the file. Supported values are `batch`, and
     * `batch_output`.
     */
    purpose?: 'batch' | 'batch_output';
  }
}

export interface FileDeleteResponse {
  id: string;

  deleted: boolean;

  object: 'file';
}

/**
 * The `File` object represents a document that has been uploaded.
 */
export interface FileInfoResponse {
  /**
   * The file identifier, which can be referenced in the API endpoints.
   */
  id?: string;

  /**
   * The size of the file, in bytes.
   */
  bytes?: number;

  /**
   * The Unix timestamp (in seconds) for when the file was created.
   */
  created_at?: number;

  /**
   * The name of the file.
   */
  filename?: string;

  /**
   * The object type, which is always `file`.
   */
  object?: 'file';

  /**
   * The intended purpose of the file. Supported values are `batch`, and
   * `batch_output`.
   */
  purpose?: 'batch' | 'batch_output';
}

export interface FileCreateParams {
  /**
   * The File object (not file name) to be uploaded.
   */
  file: Core.Uploadable;

  /**
   * The intended purpose of the uploaded file. Use "batch" for
   * [Batch API](/docs/api-reference#batches).
   */
  purpose: 'batch';
}

export declare namespace Files {
  export {
    type FileCreateResponse as FileCreateResponse,
    type FileListResponse as FileListResponse,
    type FileDeleteResponse as FileDeleteResponse,
    type FileInfoResponse as FileInfoResponse,
    type FileCreateParams as FileCreateParams,
  };
}



================================================
FILE: src/resources/index.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

export * from './shared';
export { Audio } from './audio/audio';
export {
  Batches,
  type BatchCreateResponse,
  type BatchRetrieveResponse,
  type BatchListResponse,
  type BatchCancelResponse,
  type BatchCreateParams,
} from './batches';
export { Chat } from './chat/chat';
export { Completions, type CompletionUsage } from './completions';
export {
  Embeddings,
  type CreateEmbeddingResponse,
  type Embedding,
  type EmbeddingCreateParams,
} from './embeddings';
export {
  Files,
  type FileCreateResponse,
  type FileListResponse,
  type FileDeleteResponse,
  type FileInfoResponse,
  type FileCreateParams,
} from './files';
export { Models, type Model, type ModelDeleted, type ModelListResponse } from './models';



================================================
FILE: src/resources/models.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../resource';
import * as Core from '../core';

export class Models extends APIResource {
  /**
   * Get a specific model
   */
  retrieve(model: string, options?: Core.RequestOptions): Core.APIPromise<Model> {
    return this._client.get(`/openai/v1/models/${model}`, options);
  }

  /**
   * get all available models
   */
  list(options?: Core.RequestOptions): Core.APIPromise<ModelListResponse> {
    return this._client.get('/openai/v1/models', options);
  }

  /**
   * Delete a model
   */
  delete(model: string, options?: Core.RequestOptions): Core.APIPromise<ModelDeleted> {
    return this._client.delete(`/openai/v1/models/${model}`, options);
  }
}

/**
 * Describes an OpenAI model offering that can be used with the API.
 */
export interface Model {
  /**
   * The model identifier, which can be referenced in the API endpoints.
   */
  id: string;

  /**
   * The Unix timestamp (in seconds) when the model was created.
   */
  created: number;

  /**
   * The object type, which is always "model".
   */
  object: 'model';

  /**
   * The organization that owns the model.
   */
  owned_by: string;
}

export interface ModelDeleted {
  id: string;

  deleted: boolean;

  object: string;
}

export interface ModelListResponse {
  data: Array<Model>;

  object: 'list';
}

export declare namespace Models {
  export {
    type Model as Model,
    type ModelDeleted as ModelDeleted,
    type ModelListResponse as ModelListResponse,
  };
}



================================================
FILE: src/resources/shared.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

export interface ErrorObject {
  code: string | null;

  message: string;

  param: string | null;

  type: string;
}

export interface FunctionDefinition {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain
   * underscores and dashes, with a maximum length of 64.
   */
  name: string;

  /**
   * A description of what the function does, used by the model to choose when and
   * how to call the function.
   */
  description?: string;

  /**
   * Function parameters defined as a JSON Schema object. Refer to
   * https://json-schema.org/understanding-json-schema/ for schema documentation.
   */
  parameters?: FunctionParameters;
}

/**
 * Function parameters defined as a JSON Schema object. Refer to
 * https://json-schema.org/understanding-json-schema/ for schema documentation.
 */
export type FunctionParameters = { [key: string]: unknown };



================================================
FILE: src/resources/audio/audio.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../resource';
import * as SpeechAPI from './speech';
import { Speech, SpeechCreateParams } from './speech';
import * as TranscriptionsAPI from './transcriptions';
import { Transcription, TranscriptionCreateParams, Transcriptions } from './transcriptions';
import * as TranslationsAPI from './translations';
import { Translation, TranslationCreateParams, Translations } from './translations';

export class Audio extends APIResource {
  speech: SpeechAPI.Speech = new SpeechAPI.Speech(this._client);
  transcriptions: TranscriptionsAPI.Transcriptions = new TranscriptionsAPI.Transcriptions(this._client);
  translations: TranslationsAPI.Translations = new TranslationsAPI.Translations(this._client);
}

Audio.Speech = Speech;
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;

export declare namespace Audio {
  export { Speech as Speech, type SpeechCreateParams as SpeechCreateParams };

  export {
    Transcriptions as Transcriptions,
    type Transcription as Transcription,
    type TranscriptionCreateParams as TranscriptionCreateParams,
  };

  export {
    Translations as Translations,
    type Translation as Translation,
    type TranslationCreateParams as TranslationCreateParams,
  };
}



================================================
FILE: src/resources/audio/index.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

export { Audio } from './audio';
export { Speech, type SpeechCreateParams } from './speech';
export { Transcriptions, type Transcription, type TranscriptionCreateParams } from './transcriptions';
export { Translations, type Translation, type TranslationCreateParams } from './translations';



================================================
FILE: src/resources/audio/speech.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../resource';
import * as Core from '../../core';
import { type Response } from '../../_shims/index';

export class Speech extends APIResource {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'The quick brown fox jumped over the lazy dog',
   *   model: 'playai-tts',
   *   voice: 'Fritz-PlayAI',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body: SpeechCreateParams, options?: Core.RequestOptions): Core.APIPromise<Response> {
    return this._client.post('/openai/v1/audio/speech', {
      body,
      ...options,
      headers: { Accept: 'audio/wav', ...options?.headers },
      __binaryResponse: true,
    });
  }
}

export interface SpeechCreateParams {
  /**
   * The text to generate audio for.
   */
  input: string;

  /**
   * One of the [available TTS models](/docs/text-to-speech).
   */
  model: (string & {}) | 'playai-tts' | 'playai-tts-arabic';

  /**
   * The voice to use when generating the audio. List of voices can be found
   * [here](/docs/text-to-speech).
   */
  voice: string;

  /**
   * The format of the generated audio. Supported formats are
   * `flac, mp3, mulaw, ogg, wav`.
   */
  response_format?: 'flac' | 'mp3' | 'mulaw' | 'ogg' | 'wav';

  /**
   * The sample rate for generated audio
   */
  sample_rate?: 8000 | 16000 | 22050 | 24000 | 32000 | 44100 | 48000;

  /**
   * The speed of the generated audio.
   */
  speed?: number;
}

export declare namespace Speech {
  export { type SpeechCreateParams as SpeechCreateParams };
}



================================================
FILE: src/resources/audio/transcriptions.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../resource';
import * as Core from '../../core';

export class Transcriptions extends APIResource {
  /**
   * Transcribes audio into the input language.
   *
   * @example
   * ```ts
   * const transcription =
   *   await client.audio.transcriptions.create({
   *     model: 'whisper-large-v3-turbo',
   *   });
   * ```
   */
  create(body: TranscriptionCreateParams, options?: Core.RequestOptions): Core.APIPromise<Transcription> {
    return this._client.post(
      '/openai/v1/audio/transcriptions',
      Core.multipartFormRequestOptions({ body, ...options }),
    );
  }
}

/**
 * Represents a transcription response returned by model, based on the provided
 * input.
 */
export interface Transcription {
  /**
   * The transcribed text.
   */
  text: string;
}

export interface TranscriptionCreateParams {
  /**
   * ID of the model to use. `whisper-large-v3` and `whisper-large-v3-turbo` are
   * currently available.
   */
  model: (string & {}) | 'whisper-large-v3' | 'whisper-large-v3-turbo';

  /**
   * The audio file object (not file name) to transcribe, in one of these formats:
   * flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. Either a file or a URL must
   * be provided. Note that the file field is not supported in Batch API requests.
   */
  file?: Core.Uploadable;

  /**
   * The language of the input audio. Supplying the input language in
   * [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will
   * improve accuracy and latency.
   */
  language?:
    | (string & {})
    | 'en'
    | 'zh'
    | 'de'
    | 'es'
    | 'ru'
    | 'ko'
    | 'fr'
    | 'ja'
    | 'pt'
    | 'tr'
    | 'pl'
    | 'ca'
    | 'nl'
    | 'ar'
    | 'sv'
    | 'it'
    | 'id'
    | 'hi'
    | 'fi'
    | 'vi'
    | 'he'
    | 'uk'
    | 'el'
    | 'ms'
    | 'cs'
    | 'ro'
    | 'da'
    | 'hu'
    | 'ta'
    | 'no'
    | 'th'
    | 'ur'
    | 'hr'
    | 'bg'
    | 'lt'
    | 'la'
    | 'mi'
    | 'ml'
    | 'cy'
    | 'sk'
    | 'te'
    | 'fa'
    | 'lv'
    | 'bn'
    | 'sr'
    | 'az'
    | 'sl'
    | 'kn'
    | 'et'
    | 'mk'
    | 'br'
    | 'eu'
    | 'is'
    | 'hy'
    | 'ne'
    | 'mn'
    | 'bs'
    | 'kk'
    | 'sq'
    | 'sw'
    | 'gl'
    | 'mr'
    | 'pa'
    | 'si'
    | 'km'
    | 'sn'
    | 'yo'
    | 'so'
    | 'af'
    | 'oc'
    | 'ka'
    | 'be'
    | 'tg'
    | 'sd'
    | 'gu'
    | 'am'
    | 'yi'
    | 'lo'
    | 'uz'
    | 'fo'
    | 'ht'
    | 'ps'
    | 'tk'
    | 'nn'
    | 'mt'
    | 'sa'
    | 'lb'
    | 'my'
    | 'bo'
    | 'tl'
    | 'mg'
    | 'as'
    | 'tt'
    | 'haw'
    | 'ln'
    | 'ha'
    | 'ba'
    | 'jv'
    | 'su'
    | 'yue';

  /**
   * An optional text to guide the model's style or continue a previous audio
   * segment. The [prompt](/docs/speech-text) should match the audio language.
   */
  prompt?: string;

  /**
   * The format of the transcript output, in one of these options: `json`, `text`, or
   * `verbose_json`.
   */
  response_format?: 'json' | 'text' | 'verbose_json';

  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the
   * output more random, while lower values like 0.2 will make it more focused and
   * deterministic. If set to 0, the model will use
   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to
   * automatically increase the temperature until certain thresholds are hit.
   */
  temperature?: number;

  /**
   * The timestamp granularities to populate for this transcription.
   * `response_format` must be set `verbose_json` to use timestamp granularities.
   * Either or both of these options are supported: `word`, or `segment`. Note: There
   * is no additional latency for segment timestamps, but generating word timestamps
   * incurs additional latency.
   */
  timestamp_granularities?: Array<'word' | 'segment'>;

  /**
   * The audio URL to translate/transcribe (supports Base64URL). Either a file or a
   * URL must be provided. For Batch API requests, the URL field is required since
   * the file field is not supported.
   */
  url?: string;
}

export declare namespace Transcriptions {
  export { type Transcription as Transcription, type TranscriptionCreateParams as TranscriptionCreateParams };
}



================================================
FILE: src/resources/audio/translations.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../resource';
import * as Core from '../../core';

export class Translations extends APIResource {
  /**
   * Translates audio into English.
   *
   * @example
   * ```ts
   * const translation = await client.audio.translations.create({
   *   model: 'whisper-large-v3-turbo',
   * });
   * ```
   */
  create(body: TranslationCreateParams, options?: Core.RequestOptions): Core.APIPromise<Translation> {
    return this._client.post(
      '/openai/v1/audio/translations',
      Core.multipartFormRequestOptions({ body, ...options }),
    );
  }
}

export interface Translation {
  text: string;
}

export interface TranslationCreateParams {
  /**
   * ID of the model to use. `whisper-large-v3` and `whisper-large-v3-turbo` are
   * currently available.
   */
  model: (string & {}) | 'whisper-large-v3' | 'whisper-large-v3-turbo';

  /**
   * The audio file object (not file name) translate, in one of these formats: flac,
   * mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   */
  file?: Core.Uploadable;

  /**
   * An optional text to guide the model's style or continue a previous audio
   * segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in
   * English.
   */
  prompt?: string;

  /**
   * The format of the transcript output, in one of these options: `json`, `text`, or
   * `verbose_json`.
   */
  response_format?: 'json' | 'text' | 'verbose_json';

  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the
   * output more random, while lower values like 0.2 will make it more focused and
   * deterministic. If set to 0, the model will use
   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to
   * automatically increase the temperature until certain thresholds are hit.
   */
  temperature?: number;

  /**
   * The audio URL to translate/transcribe (supports Base64URL). Either file or url
   * must be provided. When using the Batch API only url is supported.
   */
  url?: string;
}

export declare namespace Translations {
  export { type Translation as Translation, type TranslationCreateParams as TranslationCreateParams };
}



================================================
FILE: src/resources/chat/chat.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../resource';
import * as CompletionsAPI from './completions';
import {
  ChatCompletion,
  ChatCompletionAssistantMessageParam,
  ChatCompletionChunk,
  ChatCompletionContentPart,
  ChatCompletionContentPartImage,
  ChatCompletionContentPartText,
  ChatCompletionFunctionCallOption,
  ChatCompletionFunctionMessageParam,
  ChatCompletionMessage,
  ChatCompletionMessageParam,
  ChatCompletionMessageToolCall,
  ChatCompletionNamedToolChoice,
  ChatCompletionRole,
  ChatCompletionSystemMessageParam,
  ChatCompletionTokenLogprob,
  ChatCompletionTool,
  ChatCompletionToolChoiceOption,
  ChatCompletionToolMessageParam,
  ChatCompletionUserMessageParam,
  CompletionCreateParams,
  Completions,
} from './completions';

export class Chat extends APIResource {
  completions: CompletionsAPI.Completions = new CompletionsAPI.Completions(this._client);
}

Chat.Completions = Completions;

export declare namespace Chat {
  export {
    Completions as Completions,
    type ChatCompletion as ChatCompletion,
    type ChatCompletionAssistantMessageParam as ChatCompletionAssistantMessageParam,
    type ChatCompletionChunk as ChatCompletionChunk,
    type ChatCompletionContentPart as ChatCompletionContentPart,
    type ChatCompletionContentPartImage as ChatCompletionContentPartImage,
    type ChatCompletionContentPartText as ChatCompletionContentPartText,
    type ChatCompletionFunctionCallOption as ChatCompletionFunctionCallOption,
    type ChatCompletionFunctionMessageParam as ChatCompletionFunctionMessageParam,
    type ChatCompletionMessage as ChatCompletionMessage,
    type ChatCompletionMessageParam as ChatCompletionMessageParam,
    type ChatCompletionMessageToolCall as ChatCompletionMessageToolCall,
    type ChatCompletionNamedToolChoice as ChatCompletionNamedToolChoice,
    type ChatCompletionRole as ChatCompletionRole,
    type ChatCompletionSystemMessageParam as ChatCompletionSystemMessageParam,
    type ChatCompletionTokenLogprob as ChatCompletionTokenLogprob,
    type ChatCompletionTool as ChatCompletionTool,
    type ChatCompletionToolChoiceOption as ChatCompletionToolChoiceOption,
    type ChatCompletionToolMessageParam as ChatCompletionToolMessageParam,
    type ChatCompletionUserMessageParam as ChatCompletionUserMessageParam,
    type CompletionCreateParams as CompletionCreateParams,
  };
}



================================================
FILE: src/resources/chat/index.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

export { Chat } from './chat';
export {
  Completions,
  type ChatCompletion,
  type ChatCompletionAssistantMessageParam,
  type ChatCompletionChunk,
  type ChatCompletionContentPart,
  type ChatCompletionContentPartImage,
  type ChatCompletionContentPartText,
  type ChatCompletionFunctionCallOption,
  type ChatCompletionFunctionMessageParam,
  type ChatCompletionMessage,
  type ChatCompletionMessageParam,
  type ChatCompletionMessageToolCall,
  type ChatCompletionNamedToolChoice,
  type ChatCompletionRole,
  type ChatCompletionSystemMessageParam,
  type ChatCompletionTokenLogprob,
  type ChatCompletionTool,
  type ChatCompletionToolChoiceOption,
  type ChatCompletionToolMessageParam,
  type ChatCompletionUserMessageParam,
  type CompletionCreateParams,
} from './completions';



================================================
FILE: src/shims/node.ts
================================================
// @ts-ignore
import * as types from '../_shims/node-types';
import { setShims } from '../_shims/registry';
import { getRuntime } from '../_shims/node-runtime';
setShims(getRuntime());

declare module '../_shims/manual-types' {
  export namespace manual {
    // @ts-ignore
    export type Agent = types.Agent;
    // @ts-ignore
    export import fetch = types.fetch;
    // @ts-ignore
    export type Request = types.Request;
    // @ts-ignore
    export type RequestInfo = types.RequestInfo;
    // @ts-ignore
    export type RequestInit = types.RequestInit;
    // @ts-ignore
    export type Response = types.Response;
    // @ts-ignore
    export type ResponseInit = types.ResponseInit;
    // @ts-ignore
    export type ResponseType = types.ResponseType;
    // @ts-ignore
    export type BodyInit = types.BodyInit;
    // @ts-ignore
    export type Headers = types.Headers;
    // @ts-ignore
    export type HeadersInit = types.HeadersInit;
    // @ts-ignore
    export type BlobPropertyBag = types.BlobPropertyBag;
    // @ts-ignore
    export type FilePropertyBag = types.FilePropertyBag;
    // @ts-ignore
    export type FileFromPathOptions = types.FileFromPathOptions;
    // @ts-ignore
    export import FormData = types.FormData;
    // @ts-ignore
    export import File = types.File;
    // @ts-ignore
    export import Blob = types.Blob;
    // @ts-ignore
    export type Readable = types.Readable;
    // @ts-ignore
    export type FsReadStream = types.FsReadStream;
    // @ts-ignore
    export import ReadableStream = types.ReadableStream;
  }
}



================================================
FILE: src/shims/web.ts
================================================
// @ts-ignore
import * as types from '../_shims/web-types';
import { setShims } from '../_shims/registry';
import { getRuntime } from '../_shims/web-runtime';
setShims(getRuntime({ manuallyImported: true }));

declare module '../_shims/manual-types' {
  export namespace manual {
    // @ts-ignore
    export type Agent = types.Agent;
    // @ts-ignore
    export import fetch = types.fetch;
    // @ts-ignore
    export type Request = types.Request;
    // @ts-ignore
    export type RequestInfo = types.RequestInfo;
    // @ts-ignore
    export type RequestInit = types.RequestInit;
    // @ts-ignore
    export type Response = types.Response;
    // @ts-ignore
    export type ResponseInit = types.ResponseInit;
    // @ts-ignore
    export type ResponseType = types.ResponseType;
    // @ts-ignore
    export type BodyInit = types.BodyInit;
    // @ts-ignore
    export type Headers = types.Headers;
    // @ts-ignore
    export type HeadersInit = types.HeadersInit;
    // @ts-ignore
    export type BlobPropertyBag = types.BlobPropertyBag;
    // @ts-ignore
    export type FilePropertyBag = types.FilePropertyBag;
    // @ts-ignore
    export type FileFromPathOptions = types.FileFromPathOptions;
    // @ts-ignore
    export import FormData = types.FormData;
    // @ts-ignore
    export import File = types.File;
    // @ts-ignore
    export import Blob = types.Blob;
    // @ts-ignore
    export type Readable = types.Readable;
    // @ts-ignore
    export type FsReadStream = types.FsReadStream;
    // @ts-ignore
    export import ReadableStream = types.ReadableStream;
  }
}



================================================
FILE: tests/form.test.ts
================================================
import { multipartFormRequestOptions, createForm } from 'groq-sdk/core';
import { Blob } from 'groq-sdk/_shims/index';
import { toFile } from 'groq-sdk';

describe('form data validation', () => {
  test('valid values do not error', async () => {
    await multipartFormRequestOptions({
      body: {
        foo: 'foo',
        string: 1,
        bool: true,
        file: await toFile(Buffer.from('some-content')),
        blob: new Blob(['Some content'], { type: 'text/plain' }),
      },
    });
  });

  test('null', async () => {
    await expect(() =>
      multipartFormRequestOptions({
        body: {
          null: null,
        },
      }),
    ).rejects.toThrow(TypeError);
  });

  test('undefined is stripped', async () => {
    const form = await createForm({
      foo: undefined,
      bar: 'baz',
    });
    expect(form.has('foo')).toBe(false);
    expect(form.get('bar')).toBe('baz');
  });

  test('nested undefined property is stripped', async () => {
    const form = await createForm({
      bar: {
        baz: undefined,
      },
    });
    expect(Array.from(form.entries())).toEqual([]);

    const form2 = await createForm({
      bar: {
        foo: 'string',
        baz: undefined,
      },
    });
    expect(Array.from(form2.entries())).toEqual([['bar[foo]', 'string']]);
  });

  test('nested undefined array item is stripped', async () => {
    const form = await createForm({
      bar: [undefined, undefined],
    });
    expect(Array.from(form.entries())).toEqual([]);

    const form2 = await createForm({
      bar: [undefined, 'foo'],
    });
    expect(Array.from(form2.entries())).toEqual([['bar[]', 'foo']]);
  });
});



================================================
FILE: tests/index.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq from 'groq-sdk';
import { APIUserAbortError } from 'groq-sdk';
import { Headers } from 'groq-sdk/core';
import defaultFetch, { Response, type RequestInit, type RequestInfo } from 'node-fetch';

describe('instantiate client', () => {
  const env = process.env;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...env };

    console.warn = jest.fn();
  });

  afterEach(() => {
    process.env = env;
  });

  describe('defaultHeaders', () => {
    const client = new Groq({
      baseURL: 'http://localhost:5000/',
      defaultHeaders: { 'X-My-Default-Header': '2' },
      apiKey: 'My API Key',
    });

    test('they are used in the request', async () => {
      const { req } = await client.buildRequest({ path: '/foo', method: 'post' });
      expect((req.headers as Headers)['x-my-default-header']).toEqual('2');
    });

    test('can ignore `undefined` and leave the default', async () => {
      const { req } = await client.buildRequest({
        path: '/foo',
        method: 'post',
        headers: { 'X-My-Default-Header': undefined },
      });
      expect((req.headers as Headers)['x-my-default-header']).toEqual('2');
    });

    test('can be removed with `null`', async () => {
      const { req } = await client.buildRequest({
        path: '/foo',
        method: 'post',
        headers: { 'X-My-Default-Header': null },
      });
      expect(req.headers as Headers).not.toHaveProperty('x-my-default-header');
    });
  });

  describe('defaultQuery', () => {
    test('with null query params given', () => {
      const client = new Groq({
        baseURL: 'http://localhost:5000/',
        defaultQuery: { apiVersion: 'foo' },
        apiKey: 'My API Key',
      });
      expect(client.buildURL('/foo', null)).toEqual('http://localhost:5000/foo?apiVersion=foo');
    });

    test('multiple default query params', () => {
      const client = new Groq({
        baseURL: 'http://localhost:5000/',
        defaultQuery: { apiVersion: 'foo', hello: 'world' },
        apiKey: 'My API Key',
      });
      expect(client.buildURL('/foo', null)).toEqual('http://localhost:5000/foo?apiVersion=foo&hello=world');
    });

    test('overriding with `undefined`', () => {
      const client = new Groq({
        baseURL: 'http://localhost:5000/',
        defaultQuery: { hello: 'world' },
        apiKey: 'My API Key',
      });
      expect(client.buildURL('/foo', { hello: undefined })).toEqual('http://localhost:5000/foo');
    });
  });

  test('custom fetch', async () => {
    const client = new Groq({
      baseURL: 'http://localhost:5000/',
      apiKey: 'My API Key',
      fetch: (url) => {
        return Promise.resolve(
          new Response(JSON.stringify({ url, custom: true }), {
            headers: { 'Content-Type': 'application/json' },
          }),
        );
      },
    });

    const response = await client.get('/foo');
    expect(response).toEqual({ url: 'http://localhost:5000/foo', custom: true });
  });

  test('explicit global fetch', async () => {
    // make sure the global fetch type is assignable to our Fetch type
    const client = new Groq({ baseURL: 'http://localhost:5000/', apiKey: 'My API Key', fetch: defaultFetch });
  });

  test('custom signal', async () => {
    const client = new Groq({
      baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
      apiKey: 'My API Key',
      fetch: (...args) => {
        return new Promise((resolve, reject) =>
          setTimeout(
            () =>
              defaultFetch(...args)
                .then(resolve)
                .catch(reject),
            300,
          ),
        );
      },
    });

    const controller = new AbortController();
    setTimeout(() => controller.abort(), 200);

    const spy = jest.spyOn(client, 'request');

    await expect(client.get('/foo', { signal: controller.signal })).rejects.toThrowError(APIUserAbortError);
    expect(spy).toHaveBeenCalledTimes(1);
  });

  test('normalized method', async () => {
    let capturedRequest: RequestInit | undefined;
    const testFetch = async (url: RequestInfo, init: RequestInit = {}): Promise<Response> => {
      capturedRequest = init;
      return new Response(JSON.stringify({}), { headers: { 'Content-Type': 'application/json' } });
    };

    const client = new Groq({ baseURL: 'http://localhost:5000/', apiKey: 'My API Key', fetch: testFetch });

    await client.patch('/foo');
    expect(capturedRequest?.method).toEqual('PATCH');
  });

  describe('baseUrl', () => {
    test('trailing slash', () => {
      const client = new Groq({ baseURL: 'http://localhost:5000/custom/path/', apiKey: 'My API Key' });
      expect(client.buildURL('/foo', null)).toEqual('http://localhost:5000/custom/path/foo');
    });

    test('no trailing slash', () => {
      const client = new Groq({ baseURL: 'http://localhost:5000/custom/path', apiKey: 'My API Key' });
      expect(client.buildURL('/foo', null)).toEqual('http://localhost:5000/custom/path/foo');
    });

    afterEach(() => {
      process.env['GROQ_BASE_URL'] = undefined;
    });

    test('explicit option', () => {
      const client = new Groq({ baseURL: 'https://example.com', apiKey: 'My API Key' });
      expect(client.baseURL).toEqual('https://example.com');
    });

    test('env variable', () => {
      process.env['GROQ_BASE_URL'] = 'https://example.com/from_env';
      const client = new Groq({ apiKey: 'My API Key' });
      expect(client.baseURL).toEqual('https://example.com/from_env');
    });

    test('empty env variable', () => {
      process.env['GROQ_BASE_URL'] = ''; // empty
      const client = new Groq({ apiKey: 'My API Key' });
      expect(client.baseURL).toEqual('https://api.groq.com');
    });

    test('blank env variable', () => {
      process.env['GROQ_BASE_URL'] = '  '; // blank
      const client = new Groq({ apiKey: 'My API Key' });
      expect(client.baseURL).toEqual('https://api.groq.com');
    });

    test('in request options', () => {
      const client = new Groq({ apiKey: 'My API Key' });
      expect(client.buildURL('/foo', null, 'http://localhost:5000/option')).toEqual(
        'http://localhost:5000/option/foo',
      );
    });

    test('in request options overridden by client options', () => {
      const client = new Groq({ apiKey: 'My API Key', baseURL: 'http://localhost:5000/client' });
      expect(client.buildURL('/foo', null, 'http://localhost:5000/option')).toEqual(
        'http://localhost:5000/client/foo',
      );
    });

    test('in request options overridden by env variable', () => {
      process.env['GROQ_BASE_URL'] = 'http://localhost:5000/env';
      const client = new Groq({ apiKey: 'My API Key' });
      expect(client.buildURL('/foo', null, 'http://localhost:5000/option')).toEqual(
        'http://localhost:5000/env/foo',
      );
    });
  });

  test('maxRetries option is correctly set', () => {
    const client = new Groq({ maxRetries: 4, apiKey: 'My API Key' });
    expect(client.maxRetries).toEqual(4);

    // default
    const client2 = new Groq({ apiKey: 'My API Key' });
    expect(client2.maxRetries).toEqual(2);
  });

  test('with environment variable arguments', () => {
    // set options via env var
    process.env['GROQ_API_KEY'] = 'My API Key';
    const client = new Groq();
    expect(client.apiKey).toBe('My API Key');
  });

  test('with overridden environment variable arguments', () => {
    // set options via env var
    process.env['GROQ_API_KEY'] = 'another My API Key';
    const client = new Groq({ apiKey: 'My API Key' });
    expect(client.apiKey).toBe('My API Key');
  });
});

describe('request building', () => {
  const client = new Groq({ apiKey: 'My API Key' });

  describe('Content-Length', () => {
    test('handles multi-byte characters', async () => {
      const { req } = await client.buildRequest({ path: '/foo', method: 'post', body: { value: '—' } });
      expect((req.headers as Record<string, string>)['content-length']).toEqual('20');
    });

    test('handles standard characters', async () => {
      const { req } = await client.buildRequest({ path: '/foo', method: 'post', body: { value: 'hello' } });
      expect((req.headers as Record<string, string>)['content-length']).toEqual('22');
    });
  });

  describe('custom headers', () => {
    test('handles undefined', async () => {
      const { req } = await client.buildRequest({
        path: '/foo',
        method: 'post',
        body: { value: 'hello' },
        headers: { 'X-Foo': 'baz', 'x-foo': 'bar', 'x-Foo': undefined, 'x-baz': 'bam', 'X-Baz': null },
      });
      expect((req.headers as Record<string, string>)['x-foo']).toEqual('bar');
      expect((req.headers as Record<string, string>)['x-Foo']).toEqual(undefined);
      expect((req.headers as Record<string, string>)['X-Foo']).toEqual(undefined);
      expect((req.headers as Record<string, string>)['x-baz']).toEqual(undefined);
    });
  });
});

describe('retries', () => {
  test('retry on timeout', async () => {
    let count = 0;
    const testFetch = async (url: RequestInfo, { signal }: RequestInit = {}): Promise<Response> => {
      if (count++ === 0) {
        return new Promise(
          (resolve, reject) => signal?.addEventListener('abort', () => reject(new Error('timed out'))),
        );
      }
      return new Response(JSON.stringify({ a: 1 }), { headers: { 'Content-Type': 'application/json' } });
    };

    const client = new Groq({ apiKey: 'My API Key', timeout: 10, fetch: testFetch });

    expect(await client.request({ path: '/foo', method: 'get' })).toEqual({ a: 1 });
    expect(count).toEqual(2);
    expect(
      await client
        .request({ path: '/foo', method: 'get' })
        .asResponse()
        .then((r) => r.text()),
    ).toEqual(JSON.stringify({ a: 1 }));
    expect(count).toEqual(3);
  });

  test('retry count header', async () => {
    let count = 0;
    let capturedRequest: RequestInit | undefined;
    const testFetch = async (url: RequestInfo, init: RequestInit = {}): Promise<Response> => {
      count++;
      if (count <= 2) {
        return new Response(undefined, {
          status: 429,
          headers: {
            'Retry-After': '0.1',
          },
        });
      }
      capturedRequest = init;
      return new Response(JSON.stringify({ a: 1 }), { headers: { 'Content-Type': 'application/json' } });
    };

    const client = new Groq({ apiKey: 'My API Key', fetch: testFetch, maxRetries: 4 });

    expect(await client.request({ path: '/foo', method: 'get' })).toEqual({ a: 1 });

    expect((capturedRequest!.headers as Headers)['x-stainless-retry-count']).toEqual('2');
    expect(count).toEqual(3);
  });

  test('omit retry count header', async () => {
    let count = 0;
    let capturedRequest: RequestInit | undefined;
    const testFetch = async (url: RequestInfo, init: RequestInit = {}): Promise<Response> => {
      count++;
      if (count <= 2) {
        return new Response(undefined, {
          status: 429,
          headers: {
            'Retry-After': '0.1',
          },
        });
      }
      capturedRequest = init;
      return new Response(JSON.stringify({ a: 1 }), { headers: { 'Content-Type': 'application/json' } });
    };
    const client = new Groq({ apiKey: 'My API Key', fetch: testFetch, maxRetries: 4 });

    expect(
      await client.request({
        path: '/foo',
        method: 'get',
        headers: { 'X-Stainless-Retry-Count': null },
      }),
    ).toEqual({ a: 1 });

    expect(capturedRequest!.headers as Headers).not.toHaveProperty('x-stainless-retry-count');
  });

  test('omit retry count header by default', async () => {
    let count = 0;
    let capturedRequest: RequestInit | undefined;
    const testFetch = async (url: RequestInfo, init: RequestInit = {}): Promise<Response> => {
      count++;
      if (count <= 2) {
        return new Response(undefined, {
          status: 429,
          headers: {
            'Retry-After': '0.1',
          },
        });
      }
      capturedRequest = init;
      return new Response(JSON.stringify({ a: 1 }), { headers: { 'Content-Type': 'application/json' } });
    };
    const client = new Groq({
      apiKey: 'My API Key',
      fetch: testFetch,
      maxRetries: 4,
      defaultHeaders: { 'X-Stainless-Retry-Count': null },
    });

    expect(
      await client.request({
        path: '/foo',
        method: 'get',
      }),
    ).toEqual({ a: 1 });

    expect(capturedRequest!.headers as Headers).not.toHaveProperty('x-stainless-retry-count');
  });

  test('overwrite retry count header', async () => {
    let count = 0;
    let capturedRequest: RequestInit | undefined;
    const testFetch = async (url: RequestInfo, init: RequestInit = {}): Promise<Response> => {
      count++;
      if (count <= 2) {
        return new Response(undefined, {
          status: 429,
          headers: {
            'Retry-After': '0.1',
          },
        });
      }
      capturedRequest = init;
      return new Response(JSON.stringify({ a: 1 }), { headers: { 'Content-Type': 'application/json' } });
    };
    const client = new Groq({ apiKey: 'My API Key', fetch: testFetch, maxRetries: 4 });

    expect(
      await client.request({
        path: '/foo',
        method: 'get',
        headers: { 'X-Stainless-Retry-Count': '42' },
      }),
    ).toEqual({ a: 1 });

    expect((capturedRequest!.headers as Headers)['x-stainless-retry-count']).toBe('42');
  });

  test('retry on 429 with retry-after', async () => {
    let count = 0;
    const testFetch = async (url: RequestInfo, { signal }: RequestInit = {}): Promise<Response> => {
      if (count++ === 0) {
        return new Response(undefined, {
          status: 429,
          headers: {
            'Retry-After': '0.1',
          },
        });
      }
      return new Response(JSON.stringify({ a: 1 }), { headers: { 'Content-Type': 'application/json' } });
    };

    const client = new Groq({ apiKey: 'My API Key', fetch: testFetch });

    expect(await client.request({ path: '/foo', method: 'get' })).toEqual({ a: 1 });
    expect(count).toEqual(2);
    expect(
      await client
        .request({ path: '/foo', method: 'get' })
        .asResponse()
        .then((r) => r.text()),
    ).toEqual(JSON.stringify({ a: 1 }));
    expect(count).toEqual(3);
  });

  test('retry on 429 with retry-after-ms', async () => {
    let count = 0;
    const testFetch = async (url: RequestInfo, { signal }: RequestInit = {}): Promise<Response> => {
      if (count++ === 0) {
        return new Response(undefined, {
          status: 429,
          headers: {
            'Retry-After-Ms': '10',
          },
        });
      }
      return new Response(JSON.stringify({ a: 1 }), { headers: { 'Content-Type': 'application/json' } });
    };

    const client = new Groq({ apiKey: 'My API Key', fetch: testFetch });

    expect(await client.request({ path: '/foo', method: 'get' })).toEqual({ a: 1 });
    expect(count).toEqual(2);
    expect(
      await client
        .request({ path: '/foo', method: 'get' })
        .asResponse()
        .then((r) => r.text()),
    ).toEqual(JSON.stringify({ a: 1 }));
    expect(count).toEqual(3);
  });
});



================================================
FILE: tests/responses.test.ts
================================================
import { createResponseHeaders } from 'groq-sdk/core';
import { Headers } from 'groq-sdk/_shims/index';

describe('response parsing', () => {
  // TODO: test unicode characters
  test('headers are case agnostic', async () => {
    const headers = createResponseHeaders(new Headers({ 'Content-Type': 'foo', Accept: 'text/plain' }));
    expect(headers['content-type']).toEqual('foo');
    expect(headers['Content-type']).toEqual('foo');
    expect(headers['Content-Type']).toEqual('foo');
    expect(headers['accept']).toEqual('text/plain');
    expect(headers['Accept']).toEqual('text/plain');
    expect(headers['Hello-World']).toBeUndefined();
  });

  test('duplicate headers are concatenated', () => {
    const headers = createResponseHeaders(
      new Headers([
        ['Content-Type', 'text/xml'],
        ['Content-Type', 'application/json'],
      ]),
    );
    expect(headers['content-type']).toBe('text/xml, application/json');
  });
});



================================================
FILE: tests/stringifyQuery.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { Groq } from 'groq-sdk';

const { stringifyQuery } = Groq.prototype as any;

describe(stringifyQuery, () => {
  for (const [input, expected] of [
    [{ a: '1', b: 2, c: true }, 'a=1&b=2&c=true'],
    [{ a: null, b: false, c: undefined }, 'a=&b=false'],
    [{ 'a/b': 1.28341 }, `${encodeURIComponent('a/b')}=1.28341`],
    [
      { 'a/b': 'c/d', 'e=f': 'g&h' },
      `${encodeURIComponent('a/b')}=${encodeURIComponent('c/d')}&${encodeURIComponent(
        'e=f',
      )}=${encodeURIComponent('g&h')}`,
    ],
  ]) {
    it(`${JSON.stringify(input)} -> ${expected}`, () => {
      expect(stringifyQuery(input)).toEqual(expected);
    });
  }

  for (const value of [[], {}, new Date()]) {
    it(`${JSON.stringify(value)} -> <error>`, () => {
      expect(() => stringifyQuery({ value })).toThrow(`Cannot stringify type ${typeof value}`);
    });
  }
});



================================================
FILE: tests/uploads.test.ts
================================================
import fs from 'fs';
import { toFile, type ResponseLike } from 'groq-sdk/uploads';
import { File } from 'groq-sdk/_shims/index';

class MyClass {
  name: string = 'foo';
}

function mockResponse({ url, content }: { url: string; content?: Blob }): ResponseLike {
  return {
    url,
    blob: async () => content as any,
  };
}

describe('toFile', () => {
  it('throws a helpful error for mismatched types', async () => {
    await expect(
      // @ts-expect-error intentionally mismatched type
      toFile({ foo: 'string' }),
    ).rejects.toThrowErrorMatchingInlineSnapshot(
      `"Unexpected data type: object; constructor: Object; props: ["foo"]"`,
    );

    await expect(
      // @ts-expect-error intentionally mismatched type
      toFile(new MyClass()),
    ).rejects.toThrowErrorMatchingInlineSnapshot(
      `"Unexpected data type: object; constructor: MyClass; props: ["name"]"`,
    );
  });

  it('disallows string at the type-level', async () => {
    // @ts-expect-error we intentionally do not type support for `string`
    // to help people avoid passing a file path
    const file = await toFile('contents');
    expect(file.text()).resolves.toEqual('contents');
  });

  it('extracts a file name from a Response', async () => {
    const response = mockResponse({ url: 'https://example.com/my/audio.mp3' });
    const file = await toFile(response);
    expect(file.name).toEqual('audio.mp3');
  });

  it('extracts a file name from a File', async () => {
    const input = new File(['foo'], 'input.jsonl');
    const file = await toFile(input);
    expect(file.name).toEqual('input.jsonl');
  });

  it('extracts a file name from a ReadStream', async () => {
    const input = fs.createReadStream('tests/uploads.test.ts');
    const file = await toFile(input);
    expect(file.name).toEqual('uploads.test.ts');
  });

  it('does not copy File objects', async () => {
    const input = new File(['foo'], 'input.jsonl', { type: 'jsonl' });
    const file = await toFile(input);
    expect(file).toBe(input);
    expect(file.name).toEqual('input.jsonl');
    expect(file.type).toBe('jsonl');
  });
});



================================================
FILE: tests/api-resources/batches.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq from 'groq-sdk';
import { Response } from 'node-fetch';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource batches', () => {
  test('create: only required params', async () => {
    const responsePromise = client.batches.create({
      completion_window: 'completion_window',
      endpoint: '/v1/chat/completions',
      input_file_id: 'input_file_id',
    });
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('create: required and optional params', async () => {
    const response = await client.batches.create({
      completion_window: 'completion_window',
      endpoint: '/v1/chat/completions',
      input_file_id: 'input_file_id',
      metadata: { foo: 'string' },
    });
  });

  test('retrieve', async () => {
    const responsePromise = client.batches.retrieve('batch_id');
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('retrieve: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.batches.retrieve('batch_id', { path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });

  test('list', async () => {
    const responsePromise = client.batches.list();
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('list: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.batches.list({ path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });

  test('cancel', async () => {
    const responsePromise = client.batches.cancel('batch_id');
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('cancel: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.batches.cancel('batch_id', { path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });
});



================================================
FILE: tests/api-resources/embeddings.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq from 'groq-sdk';
import { Response } from 'node-fetch';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource embeddings', () => {
  test('create: only required params', async () => {
    const responsePromise = client.embeddings.create({
      input: 'The quick brown fox jumped over the lazy dog',
      model: 'nomic-embed-text-v1_5',
    });
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('create: required and optional params', async () => {
    const response = await client.embeddings.create({
      input: 'The quick brown fox jumped over the lazy dog',
      model: 'nomic-embed-text-v1_5',
      encoding_format: 'float',
      user: 'user',
    });
  });
});



================================================
FILE: tests/api-resources/files.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq, { toFile } from 'groq-sdk';
import { Response } from 'node-fetch';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource files', () => {
  test('create: only required params', async () => {
    const responsePromise = client.files.create({
      file: await toFile(Buffer.from('# my file contents'), 'README.md'),
      purpose: 'batch',
    });
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('create: required and optional params', async () => {
    const response = await client.files.create({
      file: await toFile(Buffer.from('# my file contents'), 'README.md'),
      purpose: 'batch',
    });
  });

  test('list', async () => {
    const responsePromise = client.files.list();
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('list: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.files.list({ path: '/_stainless_unknown_path' })).rejects.toThrow(Groq.NotFoundError);
  });

  test('delete', async () => {
    const responsePromise = client.files.delete('file_id');
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('delete: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.files.delete('file_id', { path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });

  test('content: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.files.content('file_id', { path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });

  test('info', async () => {
    const responsePromise = client.files.info('file_id');
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('info: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.files.info('file_id', { path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });
});



================================================
FILE: tests/api-resources/models.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq from 'groq-sdk';
import { Response } from 'node-fetch';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource models', () => {
  test('retrieve', async () => {
    const responsePromise = client.models.retrieve('model');
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('retrieve: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.models.retrieve('model', { path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });

  test('list', async () => {
    const responsePromise = client.models.list();
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('list: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.models.list({ path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });

  test('delete', async () => {
    const responsePromise = client.models.delete('model');
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('delete: request options instead of params are passed correctly', async () => {
    // ensure the request options are being passed correctly by passing an invalid HTTP method in order to cause an error
    await expect(client.models.delete('model', { path: '/_stainless_unknown_path' })).rejects.toThrow(
      Groq.NotFoundError,
    );
  });
});



================================================
FILE: tests/api-resources/audio/speech.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq from 'groq-sdk';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource speech', () => {
  // binary tests are currently broken
  test.skip('create: required and optional params', async () => {
    const response = await client.audio.speech.create({
      input: 'The quick brown fox jumped over the lazy dog',
      model: 'playai-tts',
      voice: 'Fritz-PlayAI',
      response_format: 'flac',
      sample_rate: 48000,
      speed: 1,
    });
  });
});



================================================
FILE: tests/api-resources/audio/transcriptions.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq, { toFile } from 'groq-sdk';
import { Response } from 'node-fetch';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource transcriptions', () => {
  // Unsupported either condition
  test.skip('create: only required params', async () => {
    const responsePromise = client.audio.transcriptions.create({ model: 'whisper-large-v3-turbo' });
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  // Unsupported either condition
  test.skip('create: required and optional params', async () => {
    const response = await client.audio.transcriptions.create({
      model: 'whisper-large-v3-turbo',
      file: await toFile(Buffer.from('# my file contents'), 'README.md'),
      language: 'string',
      prompt: 'prompt',
      response_format: 'json',
      temperature: 0,
      timestamp_granularities: ['word'],
      url: 'url',
    });
  });
});



================================================
FILE: tests/api-resources/audio/translations.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq, { toFile } from 'groq-sdk';
import { Response } from 'node-fetch';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource translations', () => {
  // Unsupported either condition
  test.skip('create: only required params', async () => {
    const responsePromise = client.audio.translations.create({ model: 'whisper-large-v3-turbo' });
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  // Unsupported either condition
  test.skip('create: required and optional params', async () => {
    const response = await client.audio.translations.create({
      model: 'whisper-large-v3-turbo',
      file: await toFile(Buffer.from('# my file contents'), 'README.md'),
      prompt: 'prompt',
      response_format: 'json',
      temperature: 0,
      url: 'url',
    });
  });
});



================================================
FILE: tests/api-resources/chat/completions.test.ts
================================================
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import Groq from 'groq-sdk';
import { Response } from 'node-fetch';

const client = new Groq({
  apiKey: 'My API Key',
  baseURL: process.env['TEST_API_BASE_URL'] ?? 'http://127.0.0.1:4010',
});

describe('resource completions', () => {
  test('create: only required params', async () => {
    const responsePromise = client.chat.completions.create({
      messages: [{ content: 'string', role: 'system' }],
      model: 'meta-llama/llama-4-scout-17b-16e-instruct',
    });
    const rawResponse = await responsePromise.asResponse();
    expect(rawResponse).toBeInstanceOf(Response);
    const response = await responsePromise;
    expect(response).not.toBeInstanceOf(Response);
    const dataAndResponse = await responsePromise.withResponse();
    expect(dataAndResponse.data).toBe(response);
    expect(dataAndResponse.response).toBe(rawResponse);
  });

  test('create: required and optional params', async () => {
    const response = await client.chat.completions.create({
      messages: [{ content: 'string', role: 'system', name: 'name' }],
      model: 'meta-llama/llama-4-scout-17b-16e-instruct',
      compound_custom: { models: { answering_model: 'answering_model', reasoning_model: 'reasoning_model' } },
      documents: [{ text: 'text' }],
      exclude_domains: ['string'],
      frequency_penalty: -2,
      function_call: 'none',
      functions: [{ name: 'name', description: 'description', parameters: { foo: 'bar' } }],
      include_domains: ['string'],
      include_reasoning: true,
      logit_bias: { foo: 0 },
      logprobs: true,
      max_completion_tokens: 0,
      max_tokens: 0,
      metadata: { foo: 'string' },
      n: 1,
      parallel_tool_calls: true,
      presence_penalty: -2,
      reasoning_effort: 'none',
      reasoning_format: 'hidden',
      response_format: { type: 'text' },
      search_settings: {
        country: 'country',
        exclude_domains: ['string'],
        include_domains: ['string'],
        include_images: true,
      },
      seed: 0,
      service_tier: 'auto',
      stop: '\n',
      store: true,
      stream: true,
      temperature: 1,
      tool_choice: 'none',
      tools: [
        {
          type: 'function',
          function: { name: 'name', description: 'description', parameters: { foo: 'bar' } },
        },
      ],
      top_logprobs: 0,
      top_p: 1,
      user: 'user',
    });
  });
});



================================================
FILE: .devcontainer/devcontainer.json
================================================
// For format details, see https://aka.ms/devcontainer.json. For config options, see the
// README at: https://github.com/devcontainers/templates/tree/main/src/debian
{
  "name": "Development",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:latest",
  "features": {
    "ghcr.io/devcontainers/features/node:1": {}
  },
  "postCreateCommand": "yarn install",
  "customizations": {
    "vscode": {
      "extensions": [
        "esbenp.prettier-vscode"
      ]
    }
  }
}



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI
on:
  push:
    branches-ignore:
      - 'generated'
      - 'codegen/**'
      - 'integrated/**'
      - 'stl-preview-head/**'
      - 'stl-preview-base/**'
  pull_request:
    branches-ignore:
      - 'stl-preview-head/**'
      - 'stl-preview-base/**'

jobs:
  lint:
    timeout-minutes: 10
    name: lint
    runs-on: ${{ github.repository == 'stainless-sdks/groqcloud-node' && 'depot-ubuntu-24.04' || 'ubuntu-latest' }}
    if: github.event_name == 'push' || github.event.pull_request.head.repo.fork
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Bootstrap
        run: ./scripts/bootstrap

      - name: Check types
        run: ./scripts/lint

  build:
    timeout-minutes: 5
    name: build
    runs-on: ${{ github.repository == 'stainless-sdks/groqcloud-node' && 'depot-ubuntu-24.04' || 'ubuntu-latest' }}
    if: github.event_name == 'push' || github.event.pull_request.head.repo.fork
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Bootstrap
        run: ./scripts/bootstrap

      - name: Check build
        run: ./scripts/build

      - name: Get GitHub OIDC Token
        if: github.repository == 'stainless-sdks/groqcloud-node'
        id: github-oidc
        uses: actions/github-script@v6
        with:
          script: core.setOutput('github_token', await core.getIDToken());

      - name: Upload tarball
        if: github.repository == 'stainless-sdks/groqcloud-node'
        env:
          URL: https://pkg.stainless.com/s
          AUTH: ${{ steps.github-oidc.outputs.github_token }}
          SHA: ${{ github.sha }}
        run: ./scripts/utils/upload-artifact.sh
  test:
    timeout-minutes: 10
    name: test
    runs-on: ${{ github.repository == 'stainless-sdks/groqcloud-node' && 'depot-ubuntu-24.04' || 'ubuntu-latest' }}
    if: github.event_name == 'push' || github.event.pull_request.head.repo.fork
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Bootstrap
        run: ./scripts/bootstrap

      - name: Run tests
        run: ./scripts/test



================================================
FILE: .github/workflows/publish-npm.yml
================================================
# This workflow is triggered when a GitHub release is created.
# It can also be run manually to re-publish to NPM in case it failed for some reason.
# You can run this workflow by navigating to https://www.github.com/groq/groq-typescript/actions/workflows/publish-npm.yml
name: Publish NPM
on:
  workflow_dispatch:

  release:
    types: [published]

jobs:
  publish:
    name: publish
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          yarn install

      - name: Publish to NPM
        run: |
          bash ./bin/publish-npm
        env:
          NPM_TOKEN: ${{ secrets.GROQ_NPM_TOKEN || secrets.NPM_TOKEN }}



================================================
FILE: .github/workflows/release-doctor.yml
================================================
name: Release Doctor
on:
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  release_doctor:
    name: release doctor
    runs-on: ubuntu-latest
    if: github.repository == 'groq/groq-typescript' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || startsWith(github.head_ref, 'release-please') || github.head_ref == 'next')

    steps:
      - uses: actions/checkout@v4

      - name: Check release environment
        run: |
          bash ./bin/check-release-environment
        env:
          NPM_TOKEN: ${{ secrets.GROQ_NPM_TOKEN || secrets.NPM_TOKEN }}




================================================
FILE: .github/workflows/stale.yaml
================================================
#####################################
#       DO NOT EDIT DIRECTLY.       #
# This file is managed by Terraform #
#####################################

name: "Close stale PRs"
on:
  schedule:
    - cron: "30 1 * * *"

jobs:
  stale:
    runs-on: ubuntu-latest
    # Read repo and write to PRs
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - uses: actions/stale@v9
        with:
          stale-pr-message: "This PR is stale because it has been open for 30 days with no activity. Remove stale label or comment or this will be closed in 7 days."
          close-pr-message: "This PR was closed because it has been stalled for 7 days with no activity."
          days-before-pr-stale: 30
          days-before-pr-close: 7
          exempt-pr-labels: "dependencies,security"
          operations-per-run: 60 # Default is 30


